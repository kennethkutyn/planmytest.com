import { __awaiter, __generator, __read, __spreadArray, __values } from "tslib";
import { getGlobalScope, isUrlMatchAllowlist, SAFE_HEADERS, } from '@amplitude/analytics-core';
import { filter } from 'rxjs';
import { AMPLITUDE_NETWORK_REQUEST_EVENT, IS_HEADER_CAPTURE_EXPERIMENTAL } from './constants';
var DEFAULT_STATUS_CODE_RANGE = '500-599';
function wildcardMatch(str, pattern) {
    // Escape all regex special characters except for *
    var escapedPattern = pattern.replace(/[-[\]{}()+?.,\\^$|#\s]/g, '\\$&');
    // Replace * with .*
    var regexPattern = '^' + escapedPattern.replace(/\*/g, '.*') + '$';
    var regex = new RegExp(regexPattern);
    return regex.test(str);
}
function isStatusCodeInRange(statusCode, range) {
    var e_1, _a;
    var ranges = range.split(',');
    try {
        for (var ranges_1 = __values(ranges), ranges_1_1 = ranges_1.next(); !ranges_1_1.done; ranges_1_1 = ranges_1.next()) {
            var r = ranges_1_1.value;
            var _b = __read(r.split('-').map(Number), 2), start = _b[0], end = _b[1];
            if (statusCode === start && end === undefined) {
                return true;
            }
            if (statusCode >= start && statusCode <= end) {
                return true;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (ranges_1_1 && !ranges_1_1.done && (_a = ranges_1.return)) _a.call(ranges_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return false;
}
function isCaptureRuleMatch(rule, hostname, status, url, method) {
    // check if the host is in the allowed hosts
    if (rule.hosts && !rule.hosts.find(function (host) { return wildcardMatch(hostname, host); })) {
        return;
    }
    // check if the URL is in the allowed URL patterns
    if (url && rule.urls && !isUrlMatchAllowlist(url, rule.urls)) {
        return;
    }
    // check if the method is in the allowed methods
    if (method &&
        rule.methods &&
        !rule.methods.find(function (allowedMethod) { return method.toLowerCase() === allowedMethod.toLowerCase() || allowedMethod === '*'; })) {
        return;
    }
    // check if the status code is in the allowed range
    if (status || status === 0) {
        var statusCodeRange = rule.statusCodeRange || DEFAULT_STATUS_CODE_RANGE;
        if (!isStatusCodeInRange(status, statusCodeRange)) {
            return false;
        }
    }
    return true;
}
function parseUrl(url) {
    var _a;
    if (!url) {
        return;
    }
    try {
        /* istanbul ignore next */
        var currentHref = (_a = getGlobalScope()) === null || _a === void 0 ? void 0 : _a.location.href;
        var urlObj = new URL(url, currentHref);
        var query = urlObj.searchParams.toString();
        var fragment = urlObj.hash.replace('#', '');
        var href = urlObj.href;
        var host = urlObj.host;
        urlObj.hash = '';
        urlObj.search = '';
        var hrefWithoutQueryOrHash = urlObj.href;
        return { query: query, fragment: fragment, href: href, hrefWithoutQueryOrHash: hrefWithoutQueryOrHash, host: host };
    }
    catch (e) {
        /* istanbul ignore next */
        return;
    }
}
function isAmplitudeNetworkRequestEvent(host, requestWrapper) {
    if (host.includes('amplitude.com')) {
        try {
            var body = requestWrapper.body;
            if (typeof body !== 'string') {
                return false;
            }
            var bodyObj = JSON.parse(body);
            var events = bodyObj.events;
            /* eslint-disable-next-line @typescript-eslint/no-unsafe-member-access */
            if (events.find(function (event) { return event.event_type === AMPLITUDE_NETWORK_REQUEST_EVENT; })) {
                return true;
            }
        }
        catch (e) {
            // do nothing
        }
    }
    return false;
}
/**
 * Takes a user provided header capture rule and returns a
 * HeaderCaptureRule object that sets proper default values.
 *
 * @param rule - The header capture rule to parse.
 * @returns A HeaderCaptureRule object.
 */
export function parseHeaderCaptureRule(rule) {
    if (typeof rule !== 'object' || rule === null) {
        // if rule is truthy or undefined, return SAFE_HEADERS
        if (rule) {
            return __spreadArray([], __read(SAFE_HEADERS), false);
        }
        else if (rule === undefined) {
            /* istanbul ignore next */
            var res = IS_HEADER_CAPTURE_EXPERIMENTAL ? undefined : __spreadArray([], __read(SAFE_HEADERS), false);
            return res;
        }
        return;
    }
    // if the rule is defined but empty, return undefined
    if (rule.length === 0) {
        return;
    }
    return rule;
}
function isBodyCaptureRuleEmpty(rule) {
    var _a, _b;
    /* istanbul ignore next */
    return !((_a = rule === null || rule === void 0 ? void 0 : rule.allowlist) === null || _a === void 0 ? void 0 : _a.length) && !((_b = rule === null || rule === void 0 ? void 0 : rule.blocklist) === null || _b === void 0 ? void 0 : _b.length);
}
export function shouldTrackNetworkEvent(networkEvent, options) {
    var _a;
    if (options === void 0) { options = {}; }
    var urlObj = parseUrl(networkEvent.url);
    /* istanbul ignore if */
    if (!urlObj) {
        // if the URL failed to parse, do not track the event
        // this is a probably impossible case that would only happen if the URL is malformed
        /* istanbul ignore next */
        return false;
    }
    var host = urlObj.host;
    // false if is amplitude request and not configured to track amplitude requests
    if (options.ignoreAmplitudeRequests !== false &&
        (wildcardMatch(host, '*.amplitude.com') || wildcardMatch(host, 'amplitude.com'))) {
        return false;
    }
    // false if the host is in the ignore list
    if ((_a = options.ignoreHosts) === null || _a === void 0 ? void 0 : _a.find(function (ignoreHost) { return wildcardMatch(host, ignoreHost); })) {
        return false;
    }
    // false if the status code is not 500-599 and there are no captureRules
    if (!options.captureRules &&
        networkEvent.status !== undefined &&
        !isStatusCodeInRange(networkEvent.status, DEFAULT_STATUS_CODE_RANGE)) {
        return false;
    }
    if (options.captureRules) {
        // find the first capture rule, in reverse-order,
        // that is a match (true) or a miss (false)
        var isMatch_1;
        __spreadArray([], __read(options.captureRules), false).reverse().find(function (rule) {
            isMatch_1 = isCaptureRuleMatch(rule, host, networkEvent.status, networkEvent.url, networkEvent.method);
            if (isMatch_1) {
                var responseHeadersRule = parseHeaderCaptureRule(rule.responseHeaders);
                if (networkEvent.responseWrapper && responseHeadersRule) {
                    var responseHeaders = networkEvent.responseWrapper.headers(responseHeadersRule);
                    if (responseHeaders) {
                        networkEvent.responseHeaders = responseHeaders;
                    }
                }
                // if requestHeaders rule is specified, enrich the event with the request headers
                var requestHeadersRule = parseHeaderCaptureRule(rule.requestHeaders);
                if (networkEvent.requestWrapper && requestHeadersRule) {
                    var requestHeaders = networkEvent.requestWrapper.headers(requestHeadersRule);
                    if (requestHeaders) {
                        networkEvent.requestHeaders = requestHeaders;
                    }
                }
                // if responseBody rule is specified, enrich the event with the response body
                if (networkEvent.responseWrapper && rule.responseBody && !isBodyCaptureRuleEmpty(rule.responseBody)) {
                    networkEvent.responseBodyJson = networkEvent.responseWrapper.json(rule.responseBody.allowlist, rule.responseBody.blocklist);
                }
                // if requestBody rule is specified, enrich the event with the request body
                if (networkEvent.requestWrapper && rule.requestBody && !isBodyCaptureRuleEmpty(rule.requestBody)) {
                    networkEvent.requestBodyJson = networkEvent.requestWrapper.json(rule.requestBody.allowlist, rule.requestBody.blocklist);
                }
            }
            return isMatch_1 !== undefined;
        });
        // if we found a miss (false) or no match (undefined),
        // then do not track the event
        if (!isMatch_1) {
            return false;
        }
    }
    // skip Amplitude network requests to "[Amplitude] Network Request" to avoid infinite loop
    if (networkEvent.requestWrapper && isAmplitudeNetworkRequestEvent(host, networkEvent.requestWrapper)) {
        return false;
    }
    return true;
}
export function logNetworkAnalyticsEvent(networkAnalyticsEvent, request, amplitude) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, requestBody, responseBody;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (!(request.requestBodyJson || request.responseBodyJson)) return [3 /*break*/, 2];
                    return [4 /*yield*/, Promise.all([request.requestBodyJson, request.responseBodyJson])];
                case 1:
                    _a = __read.apply(void 0, [_b.sent(), 2]), requestBody = _a[0], responseBody = _a[1];
                    if (requestBody) {
                        networkAnalyticsEvent['[Amplitude] Request Body'] = requestBody;
                    }
                    if (responseBody) {
                        networkAnalyticsEvent['[Amplitude] Response Body'] = responseBody;
                    }
                    _b.label = 2;
                case 2:
                    /* istanbul ignore next */
                    amplitude === null || amplitude === void 0 ? void 0 : amplitude.track(AMPLITUDE_NETWORK_REQUEST_EVENT, networkAnalyticsEvent);
                    return [2 /*return*/];
            }
        });
    });
}
export function trackNetworkEvents(_a) {
    var allObservables = _a.allObservables, networkTrackingOptions = _a.networkTrackingOptions, amplitude = _a.amplitude;
    var networkObservable = allObservables.networkObservable;
    var filteredNetworkObservable = networkObservable.pipe(filter(function (event) {
        // Only track network events that should be tracked,
        return shouldTrackNetworkEvent(event.event, networkTrackingOptions);
    }));
    return filteredNetworkObservable.subscribe(function (networkEvent) {
        var _a;
        var _b, _c;
        var request = networkEvent.event;
        // convert to NetworkAnalyticsEvent
        var urlObj = parseUrl(request.url);
        /* istanbul ignore if */
        if (!urlObj) {
            // if the URL failed to parse, do not track the event
            // this is a very unlikely case, because URL() shouldn't throw an exception
            // when the URL is a valid URL
            /* istanbul ignore next */
            return;
        }
        var responseBodySize = (_b = request.responseWrapper) === null || _b === void 0 ? void 0 : _b.bodySize;
        /* istanbul ignore next */
        var requestBodySize = (_c = request.requestWrapper) === null || _c === void 0 ? void 0 : _c.bodySize;
        var networkAnalyticsEvent = (_a = {},
            _a['[Amplitude] URL'] = urlObj.hrefWithoutQueryOrHash,
            _a['[Amplitude] URL Query'] = urlObj.query,
            _a['[Amplitude] URL Fragment'] = urlObj.fragment,
            _a['[Amplitude] Request Method'] = request.method,
            _a['[Amplitude] Status Code'] = request.status,
            _a['[Amplitude] Start Time'] = request.startTime,
            _a['[Amplitude] Completion Time'] = request.endTime,
            _a['[Amplitude] Duration'] = request.duration,
            _a['[Amplitude] Request Body Size'] = requestBodySize,
            _a['[Amplitude] Response Body Size'] = responseBodySize,
            _a['[Amplitude] Request Type'] = request.type,
            _a['[Amplitude] Request Headers'] = request.requestHeaders,
            _a['[Amplitude] Response Headers'] = request.responseHeaders,
            _a);
        // fire-and-forget promise that tracks the event
        void logNetworkAnalyticsEvent(networkAnalyticsEvent, request, amplitude);
    });
}
//# sourceMappingURL=track-network-event.js.map