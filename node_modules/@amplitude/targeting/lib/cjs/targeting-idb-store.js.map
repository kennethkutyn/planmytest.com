{"version":3,"file":"targeting-idb-store.js","sourceRoot":"","sources":["../../src/targeting-idb-store.ts"],"names":[],"mappings":";;;AACA,2BAAsE;AAEzD,QAAA,sBAAsB,GAAG,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC,SAAS;AAmBxE;IAAA;QAAA,iBA2HC;QA1HC,QAAG,GAAoD,EAAE,CAAC;QAE1D,gBAAW,GAAG,UAAO,MAAc;;;4BAC1B,qBAAM,IAAA,YAAM,EAAc,MAAM,EAAE,CAAC,EAAE;4BAC1C,OAAO,EAAE,UAAC,EAA6B;gCACrC,IAAI,CAAC,EAAE,CAAC,gBAAgB,CAAC,QAAQ,CAAC,sBAAsB,CAAC,EAAE;oCACzD,EAAE,CAAC,iBAAiB,CAAC,sBAAsB,EAAE;wCAC3C,OAAO,EAAE,WAAW;qCACrB,CAAC,CAAC;iCACJ;4BACH,CAAC;yBACF,CAAC,EAAA;4BARF,sBAAO,SAQL,EAAC;;;aACJ,CAAC;QAEF,mBAAc,GAAG,UAAO,MAAc;;;;;wBACpC,IAAI,IAAI,CAAC,GAAG,IAAI,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE;4BAChC,sBAAO,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,EAAC;yBACzB;wBACK,MAAM,GAAG,UAAG,MAAM,CAAC,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,mBAAgB,CAAC;wBAC/C,qBAAM,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,EAAA;;wBAAnC,EAAE,GAAG,SAA8B;wBACzC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC;wBAEtB,sBAAO,EAAE,EAAC;;;aACX,CAAC;QAEF,8BAAyB,GAAG,UAAO,EAYlC;gBAXC,SAAS,eAAA,EACT,SAAS,eAAA,EACT,SAAS,eAAA,EACT,cAAc,oBAAA,EACd,EAAE,QAAA;;;;;;;;4BASoC,qBAAM,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,SAAS,CAAC,EAAA;;4BAA3D,2BAA2B,GAAG,SAA6B;4BAC3D,oBAAoB,GAAG,2BAA2B,CAAC,CAAC,CAAC,2BAA2B,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,CAAC;4BACjG,cAAc,GAAG,oBAAoB,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC;4BAEvD,iBAAiB,yCAClB,oBAAoB,gBACtB,SAAS,0CACL,cAAc,gBAChB,SAAS,IAAG,EAAE,UAAU,EAAE,SAAS,EAAE,YAEzC,CAAC;4BACF,qBAAM,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,SAAS,WAAA,EAAE,UAAU,EAAE,iBAAiB,EAAE,CAAC,EAAA;;4BAAhE,SAAgE,CAAC;4BACjE,sBAAO,iBAAiB,EAAC;;;4BAEzB,cAAc,CAAC,IAAI,CAAC,+CAAwC,SAAS,eAAK,GAAW,CAAE,CAAC,CAAC;;gCAE3F,sBAAO,SAAS,EAAC;;;;SAClB,CAAC;QAEF,+BAA0B,GAAG,UAAO,EAQnC;gBAPC,gBAAgB,sBAAA,EAChB,cAAc,oBAAA,EACd,EAAE,QAAA;;;;;;;4BAOyB,qBAAM,EAAE,CAAC,KAAK,CAAC,MAAM,EAAE,EAAA;;4BAA1C,gBAAgB,GAAG,SAAuB;4BACvC,CAAC,GAAG,CAAC;;;iCAAE,CAAA,CAAC,GAAG,gBAAgB,CAAC,MAAM,CAAA;4BACnC,YAAY,GAAG,gBAAgB,CAAC,CAAC,CAAC,CAAC;4BACnC,wBAAwB,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,YAAY,CAAC,SAAS,CAAC;iCACjE,CAAA,YAAY,CAAC,SAAS,KAAK,gBAAgB,IAAI,wBAAwB,GAAG,8BAAsB,CAAA,EAAhG,wBAAgG;4BAClG,qBAAM,EAAE,CAAC,KAAK,CAAC,MAAM,CAAC,YAAY,CAAC,SAAS,CAAC,EAAA;;4BAA7C,SAA6C,CAAC;;;4BAJL,CAAC,EAAE,CAAA;;;;;4BAQhD,cAAc,CAAC,IAAI,CAAC,4DAAqD,GAAW,CAAE,CAAC,CAAC;;;;;;SAE3F,CAAC;QAEF,6BAAwB,GAAG,UAAO,EAYjC;gBAXC,cAAc,oBAAA,EACd,SAAS,eAAA,EACT,SAAS,eAAA,EACT,SAAS,eAAA,EACT,MAAM,YAAA;;;;;;;4BASO,qBAAM,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,EAAA;;4BAAtC,EAAE,GAAG,SAAiC;4BAEtC,EAAE,GAAG,EAAE,CAAC,WAAW,CAAsC,sBAAsB,EAAE,WAAW,CAAC,CAAC;4BACpG,IAAI,CAAC,EAAE,EAAE;gCACP,sBAAO;6BACR;4BAGyB,qBAAM,IAAI,CAAC,yBAAyB,CAAC;oCAC7D,SAAS,WAAA;oCACT,EAAE,IAAA;oCACF,cAAc,gBAAA;oCACd,SAAS,WAAA;oCACT,SAAS,WAAA;iCACV,CAAC,EAAA;;4BANI,iBAAiB,GAAG,SAMxB;4BAEF,uCAAuC;4BACvC,qBAAM,IAAI,CAAC,0BAA0B,CAAC,EAAE,gBAAgB,EAAE,SAAS,EAAE,EAAE,IAAA,EAAE,cAAc,gBAAA,EAAE,CAAC,EAAA;;4BAD1F,uCAAuC;4BACvC,SAA0F,CAAC;4BAE3F,qBAAM,EAAE,CAAC,IAAI,EAAA;;4BAAb,SAAa,CAAC;4BAEd,sBAAO,iBAAiB,EAAC;;;4BAEzB,cAAc,CAAC,IAAI,CAAC,+CAAwC,SAAS,eAAK,GAAW,CAAE,CAAC,CAAC;;gCAE3F,sBAAO,SAAS,EAAC;;;;SAClB,CAAC;IACJ,CAAC;IAAD,wBAAC;AAAD,CAAC,AA3HD,IA2HC;AA3HY,8CAAiB;AA6HjB,QAAA,iBAAiB,GAAG,IAAI,iBAAiB,EAAE,CAAC","sourcesContent":["import { Logger as ILogger } from '@amplitude/analytics-types';\nimport { DBSchema, IDBPDatabase, IDBPTransaction, openDB } from 'idb';\n\nexport const MAX_IDB_STORAGE_LENGTH = 1000 * 60 * 60 * 24 * 2; // 2 days\n\n// This type is constructed to allow for future proofing - in the future we may want\n// to track how many of each event is fired, and we may want to track event properties\n// Any further fields, like event properties, can be added to this type without causing\n// a breaking change\ntype EventData = { event_type: string };\n\ntype EventTypeStore = { [event_type: string]: { [timestamp: number]: EventData } };\nexport interface TargetingDB extends DBSchema {\n  eventTypesForSession: {\n    key: number;\n    value: {\n      sessionId: number;\n      eventTypes: EventTypeStore;\n    };\n  };\n}\n\nexport class TargetingIDBStore {\n  dbs: { [apiKey: string]: IDBPDatabase<TargetingDB> } = {};\n\n  createStore = async (dbName: string) => {\n    return await openDB<TargetingDB>(dbName, 1, {\n      upgrade: (db: IDBPDatabase<TargetingDB>) => {\n        if (!db.objectStoreNames.contains('eventTypesForSession')) {\n          db.createObjectStore('eventTypesForSession', {\n            keyPath: 'sessionId',\n          });\n        }\n      },\n    });\n  };\n\n  openOrCreateDB = async (apiKey: string) => {\n    if (this.dbs && this.dbs[apiKey]) {\n      return this.dbs[apiKey];\n    }\n    const dbName = `${apiKey.substring(0, 10)}_amp_targeting`;\n    const db = await this.createStore(dbName);\n    this.dbs[apiKey] = db;\n\n    return db;\n  };\n\n  updateEventListForSession = async ({\n    sessionId,\n    eventType,\n    eventTime,\n    loggerProvider,\n    tx,\n  }: {\n    sessionId: number;\n    eventType: string;\n    eventTime: number;\n    loggerProvider: ILogger;\n    tx: IDBPTransaction<TargetingDB, ['eventTypesForSession'], 'readwrite'>;\n  }) => {\n    try {\n      const eventTypesForSessionStorage = await tx.store.get(sessionId);\n      const eventTypesForSession = eventTypesForSessionStorage ? eventTypesForSessionStorage.eventTypes : {};\n      const eventTypeStore = eventTypesForSession[eventType] || {};\n\n      const updatedEventTypes: EventTypeStore = {\n        ...eventTypesForSession,\n        [eventType]: {\n          ...eventTypeStore,\n          [eventTime]: { event_type: eventType },\n        },\n      };\n      await tx.store.put({ sessionId, eventTypes: updatedEventTypes });\n      return updatedEventTypes;\n    } catch (e) {\n      loggerProvider.warn(`Failed to store events for targeting ${sessionId}: ${e as string}`);\n    }\n    return undefined;\n  };\n\n  deleteOldSessionEventTypes = async ({\n    currentSessionId,\n    loggerProvider,\n    tx,\n  }: {\n    currentSessionId: number;\n    loggerProvider: ILogger;\n    tx: IDBPTransaction<TargetingDB, ['eventTypesForSession'], 'readwrite'>;\n  }) => {\n    try {\n      const allEventTypeObjs = await tx.store.getAll();\n      for (let i = 0; i < allEventTypeObjs.length; i++) {\n        const eventTypeObj = allEventTypeObjs[i];\n        const amountOfTimeSinceSession = Date.now() - eventTypeObj.sessionId;\n        if (eventTypeObj.sessionId !== currentSessionId && amountOfTimeSinceSession > MAX_IDB_STORAGE_LENGTH) {\n          await tx.store.delete(eventTypeObj.sessionId);\n        }\n      }\n    } catch (e) {\n      loggerProvider.warn(`Failed to clear old session events for targeting: ${e as string}`);\n    }\n  };\n\n  storeEventTypeForSession = async ({\n    loggerProvider,\n    sessionId,\n    eventType,\n    eventTime,\n    apiKey,\n  }: {\n    loggerProvider: ILogger;\n    apiKey: string;\n    eventType: string;\n    eventTime: number;\n    sessionId: number;\n  }) => {\n    try {\n      const db = await this.openOrCreateDB(apiKey);\n\n      const tx = db.transaction<'eventTypesForSession', 'readwrite'>('eventTypesForSession', 'readwrite');\n      if (!tx) {\n        return;\n      }\n\n      // Update the list of events for the session\n      const updatedEventTypes = await this.updateEventListForSession({\n        sessionId,\n        tx,\n        loggerProvider,\n        eventType,\n        eventTime,\n      });\n\n      // Clear out sessions older than 2 days\n      await this.deleteOldSessionEventTypes({ currentSessionId: sessionId, tx, loggerProvider });\n\n      await tx.done;\n\n      return updatedEventTypes;\n    } catch (e) {\n      loggerProvider.warn(`Failed to store events for targeting ${sessionId}: ${e as string}`);\n    }\n    return undefined;\n  };\n}\n\nexport const targetingIDBStore = new TargetingIDBStore();\n"]}