import { __assign, __awaiter, __generator } from "tslib";
import { openDB } from 'idb';
export var MAX_IDB_STORAGE_LENGTH = 1000 * 60 * 60 * 24 * 2; // 2 days
var TargetingIDBStore = /** @class */ (function () {
    function TargetingIDBStore() {
        var _this = this;
        this.dbs = {};
        this.createStore = function (dbName) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, openDB(dbName, 1, {
                            upgrade: function (db) {
                                if (!db.objectStoreNames.contains('eventTypesForSession')) {
                                    db.createObjectStore('eventTypesForSession', {
                                        keyPath: 'sessionId',
                                    });
                                }
                            },
                        })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        }); };
        this.openOrCreateDB = function (apiKey) { return __awaiter(_this, void 0, void 0, function () {
            var dbName, db;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.dbs && this.dbs[apiKey]) {
                            return [2 /*return*/, this.dbs[apiKey]];
                        }
                        dbName = "".concat(apiKey.substring(0, 10), "_amp_targeting");
                        return [4 /*yield*/, this.createStore(dbName)];
                    case 1:
                        db = _a.sent();
                        this.dbs[apiKey] = db;
                        return [2 /*return*/, db];
                }
            });
        }); };
        this.updateEventListForSession = function (_a) {
            var sessionId = _a.sessionId, eventType = _a.eventType, eventTime = _a.eventTime, loggerProvider = _a.loggerProvider, tx = _a.tx;
            return __awaiter(_this, void 0, void 0, function () {
                var eventTypesForSessionStorage, eventTypesForSession, eventTypeStore, updatedEventTypes, e_1;
                var _b, _c;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            _d.trys.push([0, 3, , 4]);
                            return [4 /*yield*/, tx.store.get(sessionId)];
                        case 1:
                            eventTypesForSessionStorage = _d.sent();
                            eventTypesForSession = eventTypesForSessionStorage ? eventTypesForSessionStorage.eventTypes : {};
                            eventTypeStore = eventTypesForSession[eventType] || {};
                            updatedEventTypes = __assign(__assign({}, eventTypesForSession), (_b = {}, _b[eventType] = __assign(__assign({}, eventTypeStore), (_c = {}, _c[eventTime] = { event_type: eventType }, _c)), _b));
                            return [4 /*yield*/, tx.store.put({ sessionId: sessionId, eventTypes: updatedEventTypes })];
                        case 2:
                            _d.sent();
                            return [2 /*return*/, updatedEventTypes];
                        case 3:
                            e_1 = _d.sent();
                            loggerProvider.warn("Failed to store events for targeting ".concat(sessionId, ": ").concat(e_1));
                            return [3 /*break*/, 4];
                        case 4: return [2 /*return*/, undefined];
                    }
                });
            });
        };
        this.deleteOldSessionEventTypes = function (_a) {
            var currentSessionId = _a.currentSessionId, loggerProvider = _a.loggerProvider, tx = _a.tx;
            return __awaiter(_this, void 0, void 0, function () {
                var allEventTypeObjs, i, eventTypeObj, amountOfTimeSinceSession, e_2;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            _b.trys.push([0, 6, , 7]);
                            return [4 /*yield*/, tx.store.getAll()];
                        case 1:
                            allEventTypeObjs = _b.sent();
                            i = 0;
                            _b.label = 2;
                        case 2:
                            if (!(i < allEventTypeObjs.length)) return [3 /*break*/, 5];
                            eventTypeObj = allEventTypeObjs[i];
                            amountOfTimeSinceSession = Date.now() - eventTypeObj.sessionId;
                            if (!(eventTypeObj.sessionId !== currentSessionId && amountOfTimeSinceSession > MAX_IDB_STORAGE_LENGTH)) return [3 /*break*/, 4];
                            return [4 /*yield*/, tx.store.delete(eventTypeObj.sessionId)];
                        case 3:
                            _b.sent();
                            _b.label = 4;
                        case 4:
                            i++;
                            return [3 /*break*/, 2];
                        case 5: return [3 /*break*/, 7];
                        case 6:
                            e_2 = _b.sent();
                            loggerProvider.warn("Failed to clear old session events for targeting: ".concat(e_2));
                            return [3 /*break*/, 7];
                        case 7: return [2 /*return*/];
                    }
                });
            });
        };
        this.storeEventTypeForSession = function (_a) {
            var loggerProvider = _a.loggerProvider, sessionId = _a.sessionId, eventType = _a.eventType, eventTime = _a.eventTime, apiKey = _a.apiKey;
            return __awaiter(_this, void 0, void 0, function () {
                var db, tx, updatedEventTypes, e_3;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            _b.trys.push([0, 5, , 6]);
                            return [4 /*yield*/, this.openOrCreateDB(apiKey)];
                        case 1:
                            db = _b.sent();
                            tx = db.transaction('eventTypesForSession', 'readwrite');
                            if (!tx) {
                                return [2 /*return*/];
                            }
                            return [4 /*yield*/, this.updateEventListForSession({
                                    sessionId: sessionId,
                                    tx: tx,
                                    loggerProvider: loggerProvider,
                                    eventType: eventType,
                                    eventTime: eventTime,
                                })];
                        case 2:
                            updatedEventTypes = _b.sent();
                            // Clear out sessions older than 2 days
                            return [4 /*yield*/, this.deleteOldSessionEventTypes({ currentSessionId: sessionId, tx: tx, loggerProvider: loggerProvider })];
                        case 3:
                            // Clear out sessions older than 2 days
                            _b.sent();
                            return [4 /*yield*/, tx.done];
                        case 4:
                            _b.sent();
                            return [2 /*return*/, updatedEventTypes];
                        case 5:
                            e_3 = _b.sent();
                            loggerProvider.warn("Failed to store events for targeting ".concat(sessionId, ": ").concat(e_3));
                            return [3 /*break*/, 6];
                        case 6: return [2 /*return*/, undefined];
                    }
                });
            });
        };
    }
    return TargetingIDBStore;
}());
export { TargetingIDBStore };
export var targetingIDBStore = new TargetingIDBStore();
//# sourceMappingURL=targeting-idb-store.js.map