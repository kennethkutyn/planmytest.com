{"version":3,"file":"json-query.js","sourceRoot":"","sources":["../../../src/utils/json-query.ts"],"names":[],"mappings":"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","sourcesContent":["type Json = Record<string, any>;\n\nfunction isJsonPrimitive(json?: Json): boolean {\n  return (\n    typeof json === 'string' ||\n    typeof json === 'number' ||\n    typeof json === 'boolean' ||\n    json === null ||\n    json === undefined\n  );\n}\n\n/**\n * Prune a JSON object to only include the keys in the allowlist and excludes the keys\n * in the exclude list.\n *\n * This function is a mutative function that will modify the original JSON object.\n * This is done to avoid creating a new JSON object and copying the data.\n *\n * @param json - The JSON object to prune.\n * @param allowlist - The keys to include in the pruned JSON object.\n * @param excludelist - The keys to exclude from the pruned JSON object.\n */\nexport function pruneJson(json: Json | null | undefined, allowlist: string[], excludelist: string[]) {\n  if (!json) return;\n  // tokenize the allowlist and excludelist\n  const allowlistTokens = allowlist.map(tokenizeJsonPath);\n  const excludelistTokens = excludelist.map(tokenizeJsonPath);\n\n  _pruneJson({\n    json,\n    allowlist: allowlistTokens,\n    excludelist: excludelistTokens,\n    ancestors: [],\n  });\n}\n\nexport function _pruneJson({\n  json,\n  targetObject,\n  allowlist,\n  excludelist,\n  ancestors,\n  parentObject,\n  targetKey,\n}: {\n  json: Json;\n  targetObject?: Json;\n  allowlist: string[][];\n  excludelist: string[][];\n  ancestors: string[];\n  parentObject?: Json;\n  targetKey?: string;\n}) {\n  if (!targetObject) {\n    targetObject = json;\n  }\n\n  const keys = Object.keys(targetObject);\n  for (const key of keys) {\n    const path = [...ancestors, key];\n    if (isJsonPrimitive(targetObject[key] as Json)) {\n      // if the value does not match allowlist or matches exclude list, delete it\n      if (!hasPathMatchInList(path, allowlist) || hasPathMatchInList(path, excludelist)) {\n        delete targetObject[key];\n      }\n    } else {\n      _pruneJson({\n        json,\n        targetObject: targetObject[key] as Json,\n        allowlist,\n        excludelist,\n        ancestors: path,\n        parentObject: targetObject,\n        targetKey: key,\n      });\n    }\n  }\n\n  // if this object is empty now, delete the whole object\n  if (Object.keys(targetObject).length === 0 && parentObject && targetKey) {\n    delete parentObject[targetKey];\n  }\n}\n\n/**\n * Tokenize a JSON path string into an array of strings.\n * Escapes ~0 and ~1 to ~ and / respectively.\n *\n * e.g.) turns string \"a/b/c\" into [\"a\", \"b\", \"c\"]\n *\n * @param path - The JSON path to tokenize.\n * @returns The tokenized JSON path.\n */\nexport function tokenizeJsonPath(path: string): string[] {\n  if (path.startsWith('/')) {\n    path = path.slice(1);\n  }\n  return path.split('/').map((token) => token.replace(/~0/g, '~').replace(/~1/g, '/'));\n}\n\n/**\n * Check if a JSON path matches a path matcher.\n *\n * Rules:\n * 1. If a key in a path and a matcher are the same, then they match, move to the next\n * 2. If the matcher is a *, then it matches the key, move to the next\n * 3. If the matcher is a **, then it matches >=0 keys\n *\n * @param path - The path to check.\n * @param pathMatcher - The path matcher to check against.\n * @param i - The current index of the path.\n * @param j - The current index of the path matcher.\n * @returns True if the path matches the path matcher, false otherwise.\n */\nexport function isPathMatch(path: string[], pathMatcher: string[], i = 0, j = 0): boolean {\n  if (j === pathMatcher.length) {\n    return i === path.length;\n  }\n\n  if (i === path.length) {\n    while (j < pathMatcher.length && pathMatcher[j] === '**') {\n      j++;\n    }\n    return j === pathMatcher.length;\n  }\n\n  const currentMatcher = pathMatcher[j];\n\n  if (currentMatcher === '**') {\n    if (j + 1 === pathMatcher.length) {\n      return true;\n    }\n    for (let k = i; k <= path.length; k++) {\n      if (isPathMatch(path, pathMatcher, k, j + 1)) {\n        return true;\n      }\n    }\n    return false;\n  } else if (currentMatcher === '*' || currentMatcher === path[i]) {\n    return isPathMatch(path, pathMatcher, i + 1, j + 1);\n  } else {\n    return false;\n  }\n}\n\n/**\n * Check if a JSON path matches any of the path matchers in the allow or exclude list.\n *\n * @param path - The JSON path to check.\n * @param allowOrExcludeList - The allow or exclude list to check against.\n * @returns True if the path matches any of the path matchers in the allow or exclude list, false otherwise.\n */\nfunction hasPathMatchInList(path: string[], allowOrExcludeList: string[][]): boolean {\n  return allowOrExcludeList.some((l) => isPathMatch(path, l));\n}\n"]}