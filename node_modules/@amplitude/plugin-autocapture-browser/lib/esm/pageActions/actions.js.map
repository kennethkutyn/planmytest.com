{"version":3,"file":"actions.js","sourceRoot":"","sources":["../../../src/pageActions/actions.ts"],"names":[],"mappings":"AAIA,iBAAiB;AACjB;;;;;GAKG;AACH,MAAM,CAAC,IAAM,aAAa,GAAG,UAAC,UAAsB,EAAE,cAA2B;IAC/E,6CAA6C;IAC7C,IAAI;QACF,IAAI,UAAU,CAAC,UAAU,KAAK,aAAa,EAAE;YAC3C,4HAA4H;YAC5H,IAAI,cAAc,GAAuB,QAAQ,CAAC,eAAe,CAAC;YAClE,IAAI,UAAU,CAAC,KAAK,IAAI,cAAc,EAAE;gBACtC,cAAc,GAAG,cAAc,CAAC,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;aAC3D;YAED,kEAAkE;YAClE,IAAI,cAAc,IAAI,UAAU,CAAC,QAAQ,EAAE;gBACzC,OAAO,cAAc,CAAC,aAAa,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;aAC1D;YAED,qDAAqD;YACrD,OAAO,cAAc,CAAC;SACvB;KACF;IAAC,OAAO,KAAK,EAAE;QACd,OAAO,SAAS,CAAC;KAClB;IAED,oDAAoD;IACpD,OAAO,SAAS,CAAC;AACnB,CAAC,CAAC;AAEF,qFAAqF;AACrF,MAAM,CAAC,IAAM,cAAc,GAAG,UAC5B,OAAgC,EAChC,EAAmD,EACnD,aAA4B;IAE5B,OAAO,CAAC,OAAO,CAAC,UAAC,MAAM;QACrB,4DAA4D;QAC5D,IAAI,OAAO,MAAM,KAAK,QAAQ,EAAE;YAC9B,OAAO;SACR;QAED,IAAI,MAAM,CAAC,UAAU,KAAK,uBAAuB,EAAE;YACjD,IAAM,IAAI,GAAG,aAAa,CAAC,yBAAyB,CAAC,MAAM,CAAC,UAAU,EAAE,EAAE,CAAC,sBAAqC,CAAC,CAAC;YAElH,uBAAuB;YACvB,EAAE,CAAC,uBAAuB,CAAC,MAAM,CAAC,cAAc,CAAC,GAAG,IAAI,CAAC;SAC1D;IACH,CAAC,CAAC,CAAC;AACL,CAAC,CAAC","sourcesContent":["import type { DataSource, PageAction } from '@amplitude/analytics-core/lib/esm/types/element-interactions';\nimport type { DataExtractor } from '../data-extractor';\nimport type { ElementBasedTimestampedEvent, ElementBasedEvent } from '../helpers';\n\n// Get DataSource\n/**\n * Gets the DOM element specified by the data source configuration\n * @param dataSource - Configuration for finding the target element\n * @param contextElement - The element to start searching from\n * @returns The matching DOM element or undefined if not found\n */\nexport const getDataSource = (dataSource: DataSource, contextElement: HTMLElement) => {\n  // Only process DOM_ELEMENT type data sources\n  try {\n    if (dataSource.sourceType === 'DOM_ELEMENT') {\n      // If scope is specified, find the closest ancestor matching the scope rather than using documentElement (html) as the scope\n      let scopingElement: HTMLElement | null = document.documentElement;\n      if (dataSource.scope && contextElement) {\n        scopingElement = contextElement.closest(dataSource.scope);\n      }\n\n      // If we have both a scope and selector, find the matching element\n      if (scopingElement && dataSource.selector) {\n        return scopingElement.querySelector(dataSource.selector);\n      }\n\n      // Return scopingElement if no selector was specified\n      return scopingElement;\n    }\n  } catch (error) {\n    return undefined;\n  }\n\n  // Return undefined for non-DOM_ELEMENT data sources\n  return undefined;\n};\n\n// Execute actions for a condition and attach event properties to the event if needed\nexport const executeActions = (\n  actions: (string | PageAction)[],\n  ev: ElementBasedTimestampedEvent<ElementBasedEvent>,\n  dataExtractor: DataExtractor,\n) => {\n  actions.forEach((action) => {\n    // Skip if actions is string until action set is implemented\n    if (typeof action === 'string') {\n      return;\n    }\n\n    if (action.actionType === 'ATTACH_EVENT_PROPERTY') {\n      const data = dataExtractor.extractDataFromDataSource(action.dataSource, ev.closestTrackedAncestor as HTMLElement);\n\n      // Attach data to event\n      ev.targetElementProperties[action.destinationKey] = data;\n    }\n  });\n};\n"]}