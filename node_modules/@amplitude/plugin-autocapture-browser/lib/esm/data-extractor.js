import { __read, __spreadArray, __values } from "tslib";
import * as constants from './constants';
import { removeEmptyProperties, extractPrefixedAttributes, isElementPointerCursor, getClosestElement, isElementBasedEvent, parseAttributesToMask, } from './helpers';
import { getAncestors, getElementProperties } from './hierarchy';
import { getDataSource } from './pageActions/actions';
var CC_REGEX = /\b(?:\d[ -]*?){13,16}\b/;
var SSN_REGEX = /(\d{3}-?\d{2}-?\d{4})/g;
var EMAIL_REGEX = /[^\s@]+@[^\s@.]+\.[^\s@]+/g;
var DataExtractor = /** @class */ (function () {
    function DataExtractor(options) {
        var e_1, _a;
        var _this = this;
        var _b;
        this.replaceSensitiveString = function (text) {
            var e_2, _a;
            if (typeof text !== 'string') {
                return '';
            }
            var result = text;
            // Check for credit card number (with or without spaces/dashes)
            result = result.replace(CC_REGEX, constants.MASKED_TEXT_VALUE);
            // Check for social security number
            result = result.replace(SSN_REGEX, constants.MASKED_TEXT_VALUE);
            // Check for email
            result = result.replace(EMAIL_REGEX, constants.MASKED_TEXT_VALUE);
            try {
                // Check for additional mask text patterns
                for (var _b = __values(_this.additionalMaskTextPatterns), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var pattern = _c.value;
                    try {
                        result = result.replace(pattern, constants.MASKED_TEXT_VALUE);
                    }
                    catch (_d) {
                        // ignore invalid pattern
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return result;
        };
        // Get the DOM hierarchy of the element, starting from the target element to the root element.
        this.getHierarchy = function (element) {
            var e_3, _a;
            var _b;
            var hierarchy = [];
            if (!element) {
                return [];
            }
            // Get list of ancestors including itself and get properties at each level in the hierarchy
            var ancestors = getAncestors(element);
            // Build attributes to mask map
            var elementToAttributesToMaskMap = new Map();
            for (var i = ancestors.length - 1; i >= 0; i--) {
                var node = ancestors[i];
                if (node) {
                    var attributesToMask = parseAttributesToMask(node.getAttribute(constants.DATA_AMP_MASK_ATTRIBUTES));
                    var ancestorAttributesToMask = i === ancestors.length - 1 ? [] : (_b = elementToAttributesToMaskMap.get(ancestors[i + 1])) !== null && _b !== void 0 ? _b : new Set();
                    var combinedAttributesToMask = new Set(__spreadArray(__spreadArray([], __read(ancestorAttributesToMask), false), __read(attributesToMask), false));
                    elementToAttributesToMaskMap.set(node, combinedAttributesToMask);
                }
            }
            hierarchy = ancestors.map(function (el) { var _a; return getElementProperties(el, (_a = elementToAttributesToMaskMap.get(el)) !== null && _a !== void 0 ? _a : new Set()); });
            var _loop_1 = function (hierarchyNode) {
                if (hierarchyNode === null || hierarchyNode === void 0 ? void 0 : hierarchyNode.attrs) {
                    Object.entries(hierarchyNode.attrs).forEach(function (_a) {
                        var _b = __read(_a, 2), key = _b[0], value = _b[1];
                        if (hierarchyNode.attrs) {
                            hierarchyNode.attrs[key] = _this.replaceSensitiveString(value);
                        }
                    });
                }
            };
            try {
                // Search for and mask any sensitive attribute values
                for (var hierarchy_1 = __values(hierarchy), hierarchy_1_1 = hierarchy_1.next(); !hierarchy_1_1.done; hierarchy_1_1 = hierarchy_1.next()) {
                    var hierarchyNode = hierarchy_1_1.value;
                    _loop_1(hierarchyNode);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (hierarchy_1_1 && !hierarchy_1_1.done && (_a = hierarchy_1.return)) _a.call(hierarchy_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return hierarchy;
        };
        this.getNearestLabel = function (element) {
            var parent = element.parentElement;
            if (!parent) {
                return '';
            }
            var labelElement;
            try {
                labelElement = parent.querySelector(':scope>span,h1,h2,h3,h4,h5,h6');
            }
            catch (_a) {
                /* istanbul ignore next */
                labelElement = null;
            }
            if (labelElement) {
                /* istanbul ignore next */
                return _this.getText(labelElement);
            }
            return _this.getNearestLabel(parent);
        };
        // Returns the Amplitude event properties for the given element.
        this.getEventProperties = function (actionType, element, dataAttributePrefix) {
            var _a;
            var _b, _c, _d;
            /* istanbul ignore next */
            var tag = (_c = (_b = element === null || element === void 0 ? void 0 : element.tagName) === null || _b === void 0 ? void 0 : _b.toLowerCase) === null || _c === void 0 ? void 0 : _c.call(_b);
            /* istanbul ignore next */
            var rect = typeof element.getBoundingClientRect === 'function' ? element.getBoundingClientRect() : { left: null, top: null };
            var hierarchy = _this.getHierarchy(element);
            var currentElementAttributes = (_d = hierarchy[0]) === null || _d === void 0 ? void 0 : _d.attrs;
            var nearestLabel = _this.getNearestLabel(element);
            var attributes = extractPrefixedAttributes(currentElementAttributes !== null && currentElementAttributes !== void 0 ? currentElementAttributes : {}, dataAttributePrefix);
            /* istanbul ignore next */
            var properties = (_a = {},
                _a[constants.AMPLITUDE_EVENT_PROP_ELEMENT_HIERARCHY] = hierarchy,
                _a[constants.AMPLITUDE_EVENT_PROP_ELEMENT_TAG] = tag,
                _a[constants.AMPLITUDE_EVENT_PROP_ELEMENT_TEXT] = _this.getText(element),
                _a[constants.AMPLITUDE_EVENT_PROP_ELEMENT_POSITION_LEFT] = rect.left == null ? null : Math.round(rect.left),
                _a[constants.AMPLITUDE_EVENT_PROP_ELEMENT_POSITION_TOP] = rect.top == null ? null : Math.round(rect.top),
                _a[constants.AMPLITUDE_EVENT_PROP_ELEMENT_ATTRIBUTES] = attributes,
                _a[constants.AMPLITUDE_EVENT_PROP_ELEMENT_PARENT_LABEL] = nearestLabel,
                _a[constants.AMPLITUDE_EVENT_PROP_PAGE_URL] = window.location.href.split('?')[0],
                _a[constants.AMPLITUDE_EVENT_PROP_PAGE_TITLE] = (typeof document !== 'undefined' && _this.replaceSensitiveString(document.title)) || '',
                _a[constants.AMPLITUDE_EVENT_PROP_VIEWPORT_HEIGHT] = window.innerHeight,
                _a[constants.AMPLITUDE_EVENT_PROP_VIEWPORT_WIDTH] = window.innerWidth,
                _a);
            // id is never masked, so always include it
            properties[constants.AMPLITUDE_EVENT_PROP_ELEMENT_ID] = element.getAttribute('id') || '';
            // class is never masked, so always include it
            properties[constants.AMPLITUDE_EVENT_PROP_ELEMENT_CLASS] = element.getAttribute('class');
            properties[constants.AMPLITUDE_EVENT_PROP_ELEMENT_ARIA_LABEL] = currentElementAttributes === null || currentElementAttributes === void 0 ? void 0 : currentElementAttributes['aria-label'];
            if (tag === 'a' && actionType === 'click' && element instanceof HTMLAnchorElement) {
                properties[constants.AMPLITUDE_EVENT_PROP_ELEMENT_HREF] = _this.replaceSensitiveString(element.href); // we don't use hierarchy here because we don't want href value to be changed
            }
            return removeEmptyProperties(properties);
        };
        this.addAdditionalEventProperties = function (event, type, selectorAllowlist, dataAttributePrefix, 
        // capture the event if the cursor is a "pointer" when this element is clicked on
        // reason: a "pointer" cursor indicates that an element should be interactable
        //         regardless of the element's tag name
        isCapturingCursorPointer) {
            if (isCapturingCursorPointer === void 0) { isCapturingCursorPointer = false; }
            var baseEvent = {
                event: event,
                timestamp: Date.now(),
                type: type,
            };
            if (isElementBasedEvent(baseEvent) && baseEvent.event.target !== null) {
                if (isCapturingCursorPointer) {
                    var isCursorPointer = isElementPointerCursor(baseEvent.event.target, baseEvent.type);
                    if (isCursorPointer) {
                        baseEvent.closestTrackedAncestor = baseEvent.event.target;
                        baseEvent.targetElementProperties = _this.getEventProperties(baseEvent.type, baseEvent.closestTrackedAncestor, dataAttributePrefix);
                        return baseEvent;
                    }
                }
                // Retrieve additional event properties from the target element
                var closestTrackedAncestor = getClosestElement(baseEvent.event.target, selectorAllowlist);
                if (closestTrackedAncestor) {
                    baseEvent.closestTrackedAncestor = closestTrackedAncestor;
                    baseEvent.targetElementProperties = _this.getEventProperties(baseEvent.type, closestTrackedAncestor, dataAttributePrefix);
                }
                return baseEvent;
            }
            return baseEvent;
        };
        this.extractDataFromDataSource = function (dataSource, contextElement) {
            // Extract from DOM Element
            if (dataSource.sourceType === 'DOM_ELEMENT') {
                var sourceElement = getDataSource(dataSource, contextElement);
                if (!sourceElement) {
                    return undefined;
                }
                if (dataSource.elementExtractType === 'TEXT') {
                    return _this.getText(sourceElement);
                }
                else if (dataSource.elementExtractType === 'ATTRIBUTE' && dataSource.attribute) {
                    return sourceElement.getAttribute(dataSource.attribute);
                }
                return undefined;
            }
            // TODO: Extract from other source types
            return undefined;
        };
        this.getText = function (element) {
            // Check if element or any parent has data-amp-mask attribute
            var hasMaskAttribute = element.closest("[".concat(constants.TEXT_MASK_ATTRIBUTE, "]")) !== null;
            if (hasMaskAttribute) {
                return constants.MASKED_TEXT_VALUE;
            }
            var output = '';
            if (!element.querySelector("[".concat(constants.TEXT_MASK_ATTRIBUTE, "], [contenteditable]"))) {
                output = element.innerText || '';
            }
            else {
                var clonedTree = element.cloneNode(true);
                // replace all elements with TEXT_MASK_ATTRIBUTE attribute and contenteditable with the text MASKED_TEXT_VALUE
                clonedTree.querySelectorAll("[".concat(constants.TEXT_MASK_ATTRIBUTE, "], [contenteditable]")).forEach(function (node) {
                    node.innerText = constants.MASKED_TEXT_VALUE;
                });
                output = clonedTree.innerText || '';
            }
            return _this.replaceSensitiveString(output.substring(0, 255)).replace(/\s+/g, ' ').trim();
        };
        // Returns the element properties for the given element in Visual Labeling.
        this.getEventTagProps = function (element) {
            var _a;
            var _b, _c;
            if (!element) {
                return {};
            }
            /* istanbul ignore next */
            var tag = (_c = (_b = element === null || element === void 0 ? void 0 : element.tagName) === null || _b === void 0 ? void 0 : _b.toLowerCase) === null || _c === void 0 ? void 0 : _c.call(_b);
            var properties = (_a = {},
                _a[constants.AMPLITUDE_EVENT_PROP_ELEMENT_TAG] = tag,
                _a[constants.AMPLITUDE_EVENT_PROP_ELEMENT_TEXT] = _this.getText(element),
                _a[constants.AMPLITUDE_EVENT_PROP_PAGE_URL] = window.location.href.split('?')[0],
                _a);
            return removeEmptyProperties(properties);
        };
        var rawPatterns = (_b = options.maskTextRegex) !== null && _b !== void 0 ? _b : [];
        var compiled = [];
        try {
            for (var rawPatterns_1 = __values(rawPatterns), rawPatterns_1_1 = rawPatterns_1.next(); !rawPatterns_1_1.done; rawPatterns_1_1 = rawPatterns_1.next()) {
                var entry = rawPatterns_1_1.value;
                if (compiled.length >= constants.MAX_MASK_TEXT_PATTERNS) {
                    break;
                }
                if (entry instanceof RegExp) {
                    compiled.push(entry);
                }
                else if ('pattern' in entry && typeof entry.pattern === 'string') {
                    try {
                        compiled.push(new RegExp(entry.pattern, 'i'));
                    }
                    catch (_c) {
                        // ignore invalid pattern strings
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (rawPatterns_1_1 && !rawPatterns_1_1.done && (_a = rawPatterns_1.return)) _a.call(rawPatterns_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        this.additionalMaskTextPatterns = compiled;
    }
    return DataExtractor;
}());
export { DataExtractor };
//# sourceMappingURL=data-extractor.js.map