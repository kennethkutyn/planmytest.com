import { safeGlobal, TimeoutError, isLocalStorageAvailable, getGlobalScope, topologicalSort, FetchError, EvaluationEngine, Poller, SdkFlagApi, SdkEvaluationApi } from '@amplitude/experiment-core';
import { AnalyticsConnector } from '@amplitude/analytics-connector';
import { UAParser } from '@amplitude/ua-parser-js';

/**
 * @deprecated Update your version of the amplitude analytics-js SDK to 8.17.0+ and for seamless
 * integration with the amplitude analytics SDK.
 */
var AmplitudeUserProvider = /** @class */ (function () {
    function AmplitudeUserProvider(amplitudeInstance) {
        this.amplitudeInstance = amplitudeInstance;
    }
    AmplitudeUserProvider.prototype.getUser = function () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        return {
            device_id: (_b = (_a = this.amplitudeInstance) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.deviceId,
            user_id: (_d = (_c = this.amplitudeInstance) === null || _c === void 0 ? void 0 : _c.options) === null || _d === void 0 ? void 0 : _d.userId,
            version: (_f = (_e = this.amplitudeInstance) === null || _e === void 0 ? void 0 : _e.options) === null || _f === void 0 ? void 0 : _f.versionName,
            language: (_h = (_g = this.amplitudeInstance) === null || _g === void 0 ? void 0 : _g.options) === null || _h === void 0 ? void 0 : _h.language,
            platform: (_k = (_j = this.amplitudeInstance) === null || _j === void 0 ? void 0 : _j.options) === null || _k === void 0 ? void 0 : _k.platform,
            os: this.getOs(),
            device_model: this.getDeviceModel(),
        };
    };
    AmplitudeUserProvider.prototype.getOs = function () {
        var _a, _b, _c, _d, _e, _f;
        return [
            (_c = (_b = (_a = this.amplitudeInstance) === null || _a === void 0 ? void 0 : _a._ua) === null || _b === void 0 ? void 0 : _b.browser) === null || _c === void 0 ? void 0 : _c.name,
            (_f = (_e = (_d = this.amplitudeInstance) === null || _d === void 0 ? void 0 : _d._ua) === null || _e === void 0 ? void 0 : _e.browser) === null || _f === void 0 ? void 0 : _f.major,
        ]
            .filter(function (e) { return e !== null && e !== undefined; })
            .join(' ');
    };
    AmplitudeUserProvider.prototype.getDeviceModel = function () {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.amplitudeInstance) === null || _a === void 0 ? void 0 : _a._ua) === null || _b === void 0 ? void 0 : _b.os) === null || _c === void 0 ? void 0 : _c.name;
    };
    return AmplitudeUserProvider;
}());
/**
 * @deprecated Update your version of the amplitude analytics-js SDK to 8.17.0+ and for seamless
 * integration with the amplitude analytics SDK.
 */
var AmplitudeAnalyticsProvider = /** @class */ (function () {
    function AmplitudeAnalyticsProvider(amplitudeInstance) {
        this.amplitudeInstance = amplitudeInstance;
    }
    AmplitudeAnalyticsProvider.prototype.track = function (event) {
        this.amplitudeInstance.logEvent(event.name, event.properties);
    };
    AmplitudeAnalyticsProvider.prototype.setUserProperty = function (event) {
        var _a;
        var _b;
        // if the variant has a value, set the user property and log an event
        this.amplitudeInstance.setUserProperties((_a = {},
            _a[event.userProperty] = (_b = event.variant) === null || _b === void 0 ? void 0 : _b.value,
            _a));
    };
    AmplitudeAnalyticsProvider.prototype.unsetUserProperty = function (event) {
        var _a;
        // if the variant does not have a value, unset the user property
        this.amplitudeInstance['_logEvent']('$identify', null, null, {
            $unset: (_a = {}, _a[event.userProperty] = '-', _a),
        });
    };
    return AmplitudeAnalyticsProvider;
}());

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = {
      label: 0,
      sent: function () {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
    f,
    y,
    t,
    g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;
  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
    m = s && o[s],
    i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
    r,
    ar = [],
    e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

var parseAmplitudeCookie = function (apiKey, newFormat) {
    var e_1, _a;
    if (newFormat === void 0) { newFormat = false; }
    // Get the cookie value
    var key = generateKey(apiKey, newFormat);
    var value = undefined;
    var cookies = safeGlobal.document.cookie.split('; ');
    try {
        for (var cookies_1 = __values(cookies), cookies_1_1 = cookies_1.next(); !cookies_1_1.done; cookies_1_1 = cookies_1.next()) {
            var cookie = cookies_1_1.value;
            var _b = __read(cookie.split('=', 2), 2), cookieKey = _b[0], cookieValue = _b[1];
            if (cookieKey === key) {
                value = decodeURIComponent(cookieValue);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (cookies_1_1 && !cookies_1_1.done && (_a = cookies_1.return)) _a.call(cookies_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (!value) {
        return;
    }
    // Parse cookie value depending on format
    try {
        // New format
        if (newFormat) {
            var decoding = atob(value);
            return JSON.parse(decodeURIComponent(decoding));
        }
        // Old format
        var values = value.split('.');
        var userId = undefined;
        if (values.length >= 2 && values[1]) {
            userId = atob(values[1]);
        }
        return {
            deviceId: values[0],
            userId: userId,
        };
    }
    catch (e) {
        return;
    }
};
var parseAmplitudeLocalStorage = function (apiKey) {
    var key = generateKey(apiKey, true);
    try {
        var value = safeGlobal.localStorage.getItem(key);
        if (!value)
            return;
        var state = JSON.parse(value);
        if (typeof state !== 'object')
            return;
        return state;
    }
    catch (_a) {
        return;
    }
};
var parseAmplitudeSessionStorage = function (apiKey) {
    var key = generateKey(apiKey, true);
    try {
        var value = safeGlobal.sessionStorage.getItem(key);
        if (!value)
            return;
        var state = JSON.parse(value);
        if (typeof state !== 'object')
            return;
        return state;
    }
    catch (_a) {
        return;
    }
};
var generateKey = function (apiKey, newFormat) {
    if (newFormat) {
        if ((apiKey === null || apiKey === void 0 ? void 0 : apiKey.length) < 10) {
            return;
        }
        return "AMP_".concat(apiKey.substring(0, 10));
    }
    if ((apiKey === null || apiKey === void 0 ? void 0 : apiKey.length) < 6) {
        return;
    }
    return "amp_".concat(apiKey.substring(0, 6));
};

/**
 * Integration plugin for Amplitude Analytics. Uses the analytics connector to
 * track events and get user identity.
 *
 * On initialization, this plugin attempts to read the user identity from all
 * the storage locations and formats supported by the analytics SDK, then
 * commits the identity to the connector. The order of locations checks are:
 *  - Cookie
 *  - Cookie (Legacy)
 *  - Local Storage
 *  - Session Storage
 *
 * Events are tracked only if the connector has an event receiver set, otherwise
 * track returns false, and events are persisted and managed by the
 * IntegrationManager.
 */
var AmplitudeIntegrationPlugin = /** @class */ (function () {
    function AmplitudeIntegrationPlugin(apiKey, connector, timeoutMillis) {
        this.type = 'integration';
        this.apiKey = apiKey;
        this.identityStore = connector.identityStore;
        this.eventBridge = connector.eventBridge;
        this.contextProvider = connector.applicationContextProvider;
        this.timeoutMillis = timeoutMillis;
        this.loadPersistedState();
        if (timeoutMillis <= 0) {
            this.setup = undefined;
        }
    }
    AmplitudeIntegrationPlugin.prototype.setup = function (config, client) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                // Setup automatic fetch on amplitude identity change.
                if (config === null || config === void 0 ? void 0 : config.automaticFetchOnAmplitudeIdentityChange) {
                    this.identityStore.addIdentityListener(function () {
                        client === null || client === void 0 ? void 0 : client.fetch();
                    });
                }
                return [2 /*return*/, this.waitForConnectorIdentity(this.timeoutMillis)];
            });
        });
    };
    AmplitudeIntegrationPlugin.prototype.getUser = function () {
        var identity = this.identityStore.getIdentity();
        return {
            user_id: identity.userId,
            device_id: identity.deviceId,
            user_properties: identity.userProperties,
            version: this.contextProvider.versionName,
        };
    };
    AmplitudeIntegrationPlugin.prototype.track = function (event) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        if (!this.eventBridge.receiver) {
            return false;
        }
        this.eventBridge.logEvent({
            eventType: event.eventType,
            eventProperties: event.eventProperties,
        });
        return true;
    };
    AmplitudeIntegrationPlugin.prototype.loadPersistedState = function () {
        // Avoid reading state if the api key is undefined or an experiment
        // deployment.
        if (!this.apiKey || this.apiKey.startsWith('client-')) {
            return false;
        }
        // New cookie format
        var user = parseAmplitudeCookie(this.apiKey, true);
        if (user) {
            this.commitIdentityToConnector(user);
            return true;
        }
        // Old cookie format
        user = parseAmplitudeCookie(this.apiKey, false);
        if (user) {
            this.commitIdentityToConnector(user);
            return true;
        }
        // Local storage
        user = parseAmplitudeLocalStorage(this.apiKey);
        if (user) {
            this.commitIdentityToConnector(user);
            return true;
        }
        // Session storage
        user = parseAmplitudeSessionStorage(this.apiKey);
        if (user) {
            this.commitIdentityToConnector(user);
            return true;
        }
        return false;
    };
    AmplitudeIntegrationPlugin.prototype.commitIdentityToConnector = function (user) {
        var editor = this.identityStore.editIdentity();
        editor.setDeviceId(user.deviceId);
        if (user.userId) {
            editor.setUserId(user.userId);
        }
        editor.commit();
    };
    AmplitudeIntegrationPlugin.prototype.waitForConnectorIdentity = function (ms) {
        return __awaiter(this, void 0, void 0, function () {
            var identity;
            var _this = this;
            return __generator(this, function (_a) {
                identity = this.identityStore.getIdentity();
                if (!identity.userId && !identity.deviceId) {
                    return [2 /*return*/, Promise.race([
                            new Promise(function (resolve) {
                                var listener = function () {
                                    resolve();
                                    _this.identityStore.removeIdentityListener(listener);
                                };
                                _this.identityStore.addIdentityListener(listener);
                            }),
                            new Promise(function (_, reject) {
                                safeGlobal.setTimeout(reject, ms, 'Timed out waiting for Amplitude Analytics SDK to initialize.');
                            }),
                        ])];
                }
                return [2 /*return*/];
            });
        });
    };
    return AmplitudeIntegrationPlugin;
}());

function unfetch(e,n){return n=n||{},new Promise(function(t,r){var s=new XMLHttpRequest,o=[],u=[],i={},a=function(){return {ok:2==(s.status/100|0),statusText:s.statusText,status:s.status,url:s.responseURL,text:function(){return Promise.resolve(s.responseText)},json:function(){return Promise.resolve(JSON.parse(s.responseText))},blob:function(){return Promise.resolve(new Blob([s.response]))},clone:a,headers:{keys:function(){return o},entries:function(){return u},get:function(e){return i[e.toLowerCase()]},has:function(e){return e.toLowerCase()in i}}}};for(var l in s.open(n.method||"get",e,!0),s.onload=function(){s.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm,function(e,n,t){o.push(n=n.toLowerCase()),u.push([n,t]),i[n]=i[n]?i[n]+","+t:t;}),t(a());},s.onerror=r,s.withCredentials="include"==n.credentials,n.headers)s.setRequestHeader(l,n.headers[l]);s.send(n.body||null);})}

/**
 * @packageDocumentation
 * @internal
 */
var fetch = safeGlobal.fetch || unfetch;
/*
 * Copied from:
 * https://github.com/github/fetch/issues/175#issuecomment-284787564
 */
var timeout = function (promise, timeoutMillis) {
    // Don't timeout if timeout is null or invalid
    if (timeoutMillis == null || timeoutMillis <= 0) {
        return promise;
    }
    return new Promise(function (resolve, reject) {
        safeGlobal.setTimeout(function () {
            reject(new TimeoutError('Request timeout after ' + timeoutMillis + ' milliseconds'));
        }, timeoutMillis);
        promise.then(resolve, reject);
    });
};
var _request = function (requestUrl, method, headers, data, timeoutMillis) {
    var call = function () { return __awaiter(void 0, void 0, void 0, function () {
        var response, simpleResponse;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, fetch(requestUrl, {
                        method: method,
                        headers: headers,
                        body: data,
                    })];
                case 1:
                    response = _b.sent();
                    _a = {
                        status: response.status
                    };
                    return [4 /*yield*/, response.text()];
                case 2:
                    simpleResponse = (_a.body = _b.sent(),
                        _a);
                    return [2 /*return*/, simpleResponse];
            }
        });
    }); };
    return timeout(call(), timeoutMillis);
};
/**
 * Wrap the exposed HttpClient in a CoreClient implementation to work with
 * FlagsApi and EvaluationApi.
 */
var WrapperClient = /** @class */ (function () {
    function WrapperClient(client) {
        this.client = client;
    }
    WrapperClient.prototype.request = function (request) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.client.request(request.requestUrl, request.method, request.headers, null, request.timeoutMillis)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    return WrapperClient;
}());
var FetchHttpClient = { request: _request };

/**
 * Determines the primary source of variants before falling back.
 *
 * @category Source
 */
var Source;
(function (Source) {
    /**
     * The default way to source variants within your application. Before the
     * assignments are fetched, `getVariant(s)` will fallback to local storage
     * first, then `initialVariants` if local storage is empty. This option
     * effectively falls back to an assignment fetched previously.
     */
    Source["LocalStorage"] = "localStorage";
    /**
     * This bootstrap option is used primarily for servers-side rendering using an
     * Experiment server SDK. This bootstrap option always prefers the config
     * `initialVariants` over data in local storage, even if variants are fetched
     * successfully and stored locally.
     */
    Source["InitialVariants"] = "initialVariants";
})(Source || (Source = {}));
/**
 * Indicates from which source the variant() function determines the variant
 *
 * @category Source
 */
var VariantSource;
(function (VariantSource) {
    VariantSource["LocalStorage"] = "storage";
    VariantSource["InitialVariants"] = "initial";
    VariantSource["SecondaryLocalStorage"] = "secondary-storage";
    VariantSource["SecondaryInitialVariants"] = "secondary-initial";
    VariantSource["FallbackInline"] = "fallback-inline";
    VariantSource["FallbackConfig"] = "fallback-config";
    VariantSource["LocalEvaluation"] = "local-evaluation";
})(VariantSource || (VariantSource = {}));
/**
 * Returns true if the VariantSource is one of the fallbacks (inline or config)
 *
 * @param source a {@link VariantSource}
 * @returns true if source is {@link VariantSource.FallbackInline} or {@link VariantSource.FallbackConfig}
 */
var isFallback = function (source) {
    return (!source ||
        source === VariantSource.FallbackInline ||
        source === VariantSource.FallbackConfig ||
        source === VariantSource.SecondaryInitialVariants);
};

/**
 Defaults for Experiment Config options

 | **Option**       | **Default**                       |
 |------------------|-----------------------------------|
 | **debug**        | `false`                           |
 | **instanceName** | `$default_instance` |
 | **fallbackVariant**         | `null`                 |
 | **initialVariants**         | `null`                 |
 | **initialFlags**         | `undefined`                 |
 | **source** | `Source.LocalStorage` |
 | **serverUrl**    | `"https://api.lab.amplitude.com"` |
 | **flagsServerUrl**    | `"https://flag.lab.amplitude.com"` |
 | **serverZone**    | `"US"` |
 | **assignmentTimeoutMillis**    | `10000` |
 | **retryFailedAssignment**    | `true` |
 | **automaticExposureTracking** | `true` |
 | **pollOnStart** | `true` |
 | **flagConfigPollingIntervalMillis** | `300000` |
 | **fetchOnStart** | `true` |
 | **automaticFetchOnAmplitudeIdentityChange** | `false` |
 | **userProvider**    | `null` |
 | **analyticsProvider**    | `null` |
 | **exposureTrackingProvider**    | `null` |

 *
 * @category Configuration
 */
var Defaults = {
    debug: false,
    instanceName: '$default_instance',
    fallbackVariant: {},
    initialVariants: {},
    initialFlags: undefined,
    source: Source.LocalStorage,
    serverUrl: 'https://api.lab.amplitude.com',
    flagsServerUrl: 'https://flag.lab.amplitude.com',
    serverZone: 'US',
    fetchTimeoutMillis: 10000,
    retryFetchOnFailure: true,
    throwOnError: false,
    automaticExposureTracking: true,
    pollOnStart: true,
    flagConfigPollingIntervalMillis: 300000,
    fetchOnStart: true,
    automaticFetchOnAmplitudeIdentityChange: false,
    userProvider: null,
    analyticsProvider: null,
    exposureTrackingProvider: null,
    httpClient: FetchHttpClient,
};

var version = "1.16.2";

var MAX_QUEUE_SIZE = 512;
/**
 * Handles integration plugin management, event persistence and deduplication.
 */
var IntegrationManager = /** @class */ (function () {
    function IntegrationManager(config, client) {
        var _this = this;
        var _a;
        this.isReady = new Promise(function (resolve) {
            _this.resolve = resolve;
        });
        this.config = config;
        this.client = client;
        var instanceName = (_a = config.instanceName) !== null && _a !== void 0 ? _a : Defaults.instanceName;
        this.queue = new PersistentTrackingQueue(instanceName);
        this.cache = new SessionDedupeCache(instanceName);
    }
    /**
     * Returns a promise when the integration has completed setup. If no
     * integration has been set, returns a resolved promise.
     */
    IntegrationManager.prototype.ready = function () {
        if (!this.integration) {
            return Promise.resolve();
        }
        return this.isReady;
    };
    /**
     * Set the integration to be managed. An existing integration is torndown,
     * and the new integration is setup. This function resolves the promise
     * returned by ready() if it has not already been resolved.
     *
     * @param integration the integration to manage.
     */
    IntegrationManager.prototype.setIntegration = function (integration) {
        var _this = this;
        if (this.integration && this.integration.teardown) {
            void this.integration.teardown();
        }
        this.integration = integration;
        if (integration.setup) {
            this.integration.setup(this.config, this.client).then(function () {
                _this.queue.setTracker(_this.integration.track.bind(integration));
                _this.resolve();
            }, function () {
                _this.queue.setTracker(_this.integration.track.bind(integration));
                _this.resolve();
            });
        }
        else {
            this.queue.setTracker(this.integration.track.bind(integration));
            this.resolve();
        }
    };
    /**
     * Get the user from the integration. If no integration is set, returns an
     * empty object.
     */
    IntegrationManager.prototype.getUser = function () {
        if (!this.integration) {
            return {};
        }
        return this.integration.getUser();
    };
    /**
     * Deduplicates exposures using session storage, then tracks the event to the
     * integration. If no integration is set, or if the integration returns false,
     * the event is persisted in local storage.
     *
     * @param exposure
     */
    IntegrationManager.prototype.track = function (exposure) {
        if (this.cache.shouldTrack(exposure)) {
            var event_1 = this.getExposureEvent(exposure);
            this.queue.push(event_1);
        }
    };
    IntegrationManager.prototype.getExposureEvent = function (exposure) {
        var _a, _b, _c;
        var event = {
            eventType: '$exposure',
            eventProperties: exposure,
        };
        if ((_a = exposure.metadata) === null || _a === void 0 ? void 0 : _a.exposureEvent) {
            // Metadata specifically passes the exposure event definition
            event = {
                eventType: (_b = exposure.metadata) === null || _b === void 0 ? void 0 : _b.exposureEvent,
                eventProperties: exposure,
            };
        }
        else if (((_c = exposure.metadata) === null || _c === void 0 ? void 0 : _c.deliveryMethod) === 'web') {
            // Web experiments track impression events by default
            event = {
                eventType: '$impression',
                eventProperties: exposure,
            };
        }
        return event;
    };
    return IntegrationManager;
}());
var SessionDedupeCache = /** @class */ (function () {
    function SessionDedupeCache(instanceName) {
        this.isSessionStorageAvailable = checkIsSessionStorageAvailable();
        this.inMemoryCache = {};
        this.storageKey = "EXP_sent_v2_".concat(instanceName);
        // Remove previous version of storage if it exists.
        if (this.isSessionStorageAvailable) {
            safeGlobal.sessionStorage.removeItem("EXP_sent_".concat(instanceName));
        }
    }
    SessionDedupeCache.prototype.shouldTrack = function (exposure) {
        var _a;
        // Always track web impressions.
        if (((_a = exposure.metadata) === null || _a === void 0 ? void 0 : _a.deliveryMethod) === 'web') {
            return true;
        }
        this.loadCache();
        var cachedExposure = this.inMemoryCache[exposure.flag_key];
        var shouldTrack = false;
        if (!cachedExposure || cachedExposure.variant !== exposure.variant) {
            shouldTrack = true;
            this.inMemoryCache[exposure.flag_key] = exposure;
        }
        this.storeCache();
        return shouldTrack;
    };
    SessionDedupeCache.prototype.loadCache = function () {
        if (this.isSessionStorageAvailable) {
            var storedCache = safeGlobal.sessionStorage.getItem(this.storageKey);
            this.inMemoryCache = storedCache ? JSON.parse(storedCache) : {};
        }
    };
    SessionDedupeCache.prototype.storeCache = function () {
        if (this.isSessionStorageAvailable) {
            safeGlobal.sessionStorage.setItem(this.storageKey, JSON.stringify(this.inMemoryCache));
        }
    };
    return SessionDedupeCache;
}());
var PersistentTrackingQueue = /** @class */ (function () {
    function PersistentTrackingQueue(instanceName, maxQueueSize) {
        if (maxQueueSize === void 0) { maxQueueSize = MAX_QUEUE_SIZE; }
        this.isLocalStorageAvailable = isLocalStorageAvailable();
        this.inMemoryQueue = [];
        this.storageKey = "EXP_unsent_".concat(instanceName);
        this.maxQueueSize = maxQueueSize;
    }
    PersistentTrackingQueue.prototype.push = function (event) {
        this.loadQueue();
        this.inMemoryQueue.push(event);
        this.flush();
        this.storeQueue();
    };
    PersistentTrackingQueue.prototype.setTracker = function (tracker) {
        var _this = this;
        this.tracker = tracker;
        this.poller = safeGlobal.setInterval(function () {
            _this.loadFlushStore();
        }, 1000);
        this.loadFlushStore();
    };
    PersistentTrackingQueue.prototype.flush = function () {
        var e_1, _a;
        if (!this.tracker)
            return;
        if (this.inMemoryQueue.length === 0)
            return;
        try {
            for (var _b = __values(this.inMemoryQueue), _c = _b.next(); !_c.done; _c = _b.next()) {
                var event_2 = _c.value;
                try {
                    if (!this.tracker(event_2)) {
                        return;
                    }
                }
                catch (e) {
                    return;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        this.inMemoryQueue = [];
        if (this.poller) {
            safeGlobal.clearInterval(this.poller);
            this.poller = undefined;
        }
    };
    PersistentTrackingQueue.prototype.loadQueue = function () {
        if (this.isLocalStorageAvailable) {
            var storedQueue = safeGlobal.localStorage.getItem(this.storageKey);
            this.inMemoryQueue = storedQueue ? JSON.parse(storedQueue) : [];
        }
    };
    PersistentTrackingQueue.prototype.storeQueue = function () {
        if (this.isLocalStorageAvailable) {
            // Trim the queue if it is too large.
            if (this.inMemoryQueue.length > this.maxQueueSize) {
                this.inMemoryQueue = this.inMemoryQueue.slice(this.inMemoryQueue.length - this.maxQueueSize);
            }
            safeGlobal.localStorage.setItem(this.storageKey, JSON.stringify(this.inMemoryQueue));
        }
    };
    PersistentTrackingQueue.prototype.loadFlushStore = function () {
        this.loadQueue();
        this.flush();
        this.storeQueue();
    };
    return PersistentTrackingQueue;
}());
var checkIsSessionStorageAvailable = function () {
    var globalScope = getGlobalScope();
    if (globalScope) {
        try {
            var testKey = 'EXP_test';
            globalScope.sessionStorage.setItem(testKey, testKey);
            globalScope.sessionStorage.removeItem(testKey);
            return true;
        }
        catch (e) {
            return false;
        }
    }
    return false;
};

var LocalStorage = /** @class */ (function () {
    function LocalStorage() {
        this.globalScope = getGlobalScope();
    }
    LocalStorage.prototype.get = function (key) {
        var _a;
        return (_a = this.globalScope) === null || _a === void 0 ? void 0 : _a.localStorage.getItem(key);
    };
    LocalStorage.prototype.put = function (key, value) {
        var _a;
        (_a = this.globalScope) === null || _a === void 0 ? void 0 : _a.localStorage.setItem(key, value);
    };
    LocalStorage.prototype.delete = function (key) {
        var _a;
        (_a = this.globalScope) === null || _a === void 0 ? void 0 : _a.localStorage.removeItem(key);
    };
    return LocalStorage;
}());

var getVariantStorage = function (deploymentKey, instanceName, storage) {
    var truncatedDeployment = deploymentKey.substring(deploymentKey.length - 6);
    var namespace = "amp-exp-".concat(instanceName, "-").concat(truncatedDeployment);
    return new LoadStoreCache(namespace, storage, transformVariantFromStorage);
};
var getFlagStorage = function (deploymentKey, instanceName, storage) {
    if (storage === void 0) { storage = new LocalStorage(); }
    var truncatedDeployment = deploymentKey.substring(deploymentKey.length - 6);
    var namespace = "amp-exp-".concat(instanceName, "-").concat(truncatedDeployment, "-flags");
    return new LoadStoreCache(namespace, storage);
};
var LoadStoreCache = /** @class */ (function () {
    function LoadStoreCache(namespace, storage, transformer) {
        this.cache = {};
        this.namespace = namespace;
        this.storage = storage;
        this.transformer = transformer;
    }
    LoadStoreCache.prototype.get = function (key) {
        return this.cache[key];
    };
    LoadStoreCache.prototype.getAll = function () {
        return __assign({}, this.cache);
    };
    LoadStoreCache.prototype.put = function (key, value) {
        this.cache[key] = value;
    };
    LoadStoreCache.prototype.putAll = function (values) {
        var e_1, _a;
        try {
            for (var _b = __values(Object.keys(values)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                this.cache[key] = values[key];
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    LoadStoreCache.prototype.remove = function (key) {
        delete this.cache[key];
    };
    LoadStoreCache.prototype.clear = function () {
        this.cache = {};
    };
    LoadStoreCache.prototype.load = function () {
        var e_2, _a;
        var rawValues = this.storage.get(this.namespace);
        var jsonValues;
        try {
            jsonValues = JSON.parse(rawValues) || {};
        }
        catch (_b) {
            // Do nothing
            return;
        }
        var values = {};
        try {
            for (var _c = __values(Object.keys(jsonValues)), _d = _c.next(); !_d.done; _d = _c.next()) {
                var key = _d.value;
                try {
                    var value = void 0;
                    if (this.transformer) {
                        value = this.transformer(jsonValues[key]);
                    }
                    else {
                        value = jsonValues[key];
                    }
                    if (value) {
                        values[key] = value;
                    }
                }
                catch (_e) {
                    // Do nothing
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_2) throw e_2.error; }
        }
        this.clear();
        this.putAll(values);
    };
    LoadStoreCache.prototype.store = function (values) {
        if (values === void 0) { values = this.cache; }
        this.storage.put(this.namespace, JSON.stringify(values));
    };
    return LoadStoreCache;
}());
var transformVariantFromStorage = function (storageValue) {
    if (typeof storageValue === 'string') {
        // From v0 string format
        return {
            key: storageValue,
            value: storageValue,
        };
    }
    else if (typeof storageValue === 'object') {
        // From v1 or v2 object format
        var key = storageValue['key'];
        var value = storageValue['value'];
        var payload = storageValue['payload'];
        var metadata = storageValue['metadata'];
        var experimentKey = storageValue['expKey'];
        if (metadata && metadata.experimentKey) {
            experimentKey = metadata.experimentKey;
        }
        else if (experimentKey) {
            metadata = metadata || {};
            metadata['experimentKey'] = experimentKey;
        }
        var variant = {};
        if (key) {
            variant.key = key;
        }
        else if (value) {
            variant.key = value;
        }
        if (value)
            variant.value = value;
        if (metadata)
            variant.metadata = metadata;
        if (payload)
            variant.payload = payload;
        if (experimentKey)
            variant.expKey = experimentKey;
        return variant;
    }
};

var SessionStorage = /** @class */ (function () {
    function SessionStorage() {
        this.globalScope = getGlobalScope();
    }
    SessionStorage.prototype.get = function (key) {
        var _a;
        return (_a = this.globalScope) === null || _a === void 0 ? void 0 : _a.sessionStorage.getItem(key);
    };
    SessionStorage.prototype.put = function (key, value) {
        var _a;
        (_a = this.globalScope) === null || _a === void 0 ? void 0 : _a.sessionStorage.setItem(key, value);
    };
    SessionStorage.prototype.delete = function (key) {
        var _a;
        (_a = this.globalScope) === null || _a === void 0 ? void 0 : _a.sessionStorage.removeItem(key);
    };
    return SessionStorage;
}());

/**
 * Event for tracking a user's exposure to a variant. This event will not count
 * towards your analytics event volume.
 *
 * @deprecated use ExposureTrackingProvider instead
 */
var exposureEvent = function (user, key, variant, source) {
    var _a;
    var name = '[Experiment] Exposure';
    var value = variant === null || variant === void 0 ? void 0 : variant.value;
    var userProperty = "[Experiment] ".concat(key);
    return {
        name: name,
        user: user,
        key: key,
        variant: variant,
        userProperty: userProperty,
        properties: {
            key: key,
            variant: value,
            source: source,
        },
        userProperties: (_a = {},
            _a[userProperty] = value,
            _a),
    };
};

var isNullOrUndefined = function (value) {
    return value === null || value === undefined;
};
var isNullUndefinedOrEmpty = function (value) {
    if (isNullOrUndefined(value))
        return true;
    return value && Object.keys(value).length === 0;
};
/**
 * Filters out null and undefined values from an object, returning a new object
 * with only defined values. This is useful for config merging where you want
 * defaults to take precedence over explicit null/undefined values.
 */
var filterNullUndefined = function (obj) {
    var e_1, _a;
    if (!obj || typeof obj !== 'object') {
        return {};
    }
    var filtered = {};
    try {
        for (var _b = __values(Object.entries(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
            if (!isNullOrUndefined(value)) {
                filtered[key] = value;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return filtered;
};
var isLocalEvaluationMode = function (flag) {
    var _a;
    return ((_a = flag === null || flag === void 0 ? void 0 : flag.metadata) === null || _a === void 0 ? void 0 : _a.evaluationMode) === 'local';
};

var Backoff = /** @class */ (function () {
    function Backoff(attempts, min, max, scalar) {
        this.started = false;
        this.done = false;
        this.attempts = attempts;
        this.min = min;
        this.max = max;
        this.scalar = scalar;
    }
    Backoff.prototype.start = function (fn) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.started) {
                            this.started = true;
                        }
                        else {
                            throw Error('Backoff already started');
                        }
                        return [4 /*yield*/, this.backoff(fn, 0, this.min)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    Backoff.prototype.cancel = function () {
        this.done = true;
        clearTimeout(this.timeoutHandle);
    };
    Backoff.prototype.backoff = function (fn, attempt, delay) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                if (this.done) {
                    return [2 /*return*/];
                }
                this.timeoutHandle = safeGlobal.setTimeout(function () { return __awaiter(_this, void 0, void 0, function () {
                    var nextAttempt, nextDelay;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                _a.trys.push([0, 2, , 3]);
                                return [4 /*yield*/, fn()];
                            case 1:
                                _a.sent();
                                return [3 /*break*/, 3];
                            case 2:
                                _a.sent();
                                nextAttempt = attempt + 1;
                                if (nextAttempt < this.attempts) {
                                    nextDelay = Math.min(delay * this.scalar, this.max);
                                    this.backoff(fn, nextAttempt, nextDelay);
                                }
                                return [3 /*break*/, 3];
                            case 3: return [2 /*return*/];
                        }
                    });
                }); }, delay);
                return [2 /*return*/];
            });
        });
    };
    return Backoff;
}());

var convertUserToContext = function (user) {
    var e_1, _a;
    var _b, _c;
    if (!user) {
        return {};
    }
    var context = { user: user };
    // add page context
    var globalScope = getGlobalScope();
    if (globalScope) {
        context.page = {
            url: globalScope.location.href,
        };
    }
    var groups = {};
    if (!user.groups) {
        return context;
    }
    try {
        for (var _d = __values(Object.keys(user.groups)), _e = _d.next(); !_e.done; _e = _d.next()) {
            var groupType = _e.value;
            var groupNames = user.groups[groupType];
            if (groupNames.length > 0 && groupNames[0]) {
                var groupName = groupNames[0];
                var groupNameMap = {
                    group_name: groupName,
                };
                // Check for group properties
                var groupProperties = (_c = (_b = user.group_properties) === null || _b === void 0 ? void 0 : _b[groupType]) === null || _c === void 0 ? void 0 : _c[groupName];
                if (groupProperties && Object.keys(groupProperties).length > 0) {
                    groupNameMap['group_properties'] = groupProperties;
                }
                groups[groupType] = groupNameMap;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (Object.keys(groups).length > 0) {
        context['groups'] = groups;
    }
    delete context.user['groups'];
    delete context.user['group_properties'];
    return context;
};
var convertVariant = function (value) {
    if (value === null || value === undefined) {
        return {};
    }
    if (typeof value == 'string') {
        return {
            key: value,
            value: value,
        };
    }
    else {
        return value;
    }
};
var convertEvaluationVariantToVariant = function (evaluationVariant) {
    if (!evaluationVariant) {
        return {};
    }
    var experimentKey = undefined;
    if (evaluationVariant.metadata) {
        experimentKey = evaluationVariant.metadata['experimentKey'];
    }
    var variant = {};
    if (evaluationVariant.key)
        variant.key = evaluationVariant.key;
    if (evaluationVariant.value)
        variant.value = evaluationVariant.value;
    if (evaluationVariant.payload)
        variant.payload = evaluationVariant.payload;
    if (experimentKey)
        variant.expKey = experimentKey;
    if (evaluationVariant.metadata)
        variant.metadata = evaluationVariant.metadata;
    return variant;
};

/**
 * A wrapper for an analytics provider which only sends one exposure event per
 * flag, per variant, per session. In other words, wrapping an analytics
 * provider in this class will prevent the same exposure event to be sent twice
 * in one session.
 */
var SessionAnalyticsProvider = /** @class */ (function () {
    function SessionAnalyticsProvider(analyticsProvider) {
        // In memory record of flagKey and variant value to in order to only set
        // user properties and track an exposure event once per session unless the
        // variant value changes
        this.setProperties = {};
        this.unsetProperties = {};
        this.analyticsProvider = analyticsProvider;
    }
    SessionAnalyticsProvider.prototype.track = function (event) {
        if (this.setProperties[event.key] == event.variant.value) {
            return;
        }
        else {
            this.setProperties[event.key] = event.variant.value;
            delete this.unsetProperties[event.key];
        }
        this.analyticsProvider.track(event);
    };
    SessionAnalyticsProvider.prototype.setUserProperty = function (event) {
        if (this.setProperties[event.key] == event.variant.value) {
            return;
        }
        this.analyticsProvider.setUserProperty(event);
    };
    SessionAnalyticsProvider.prototype.unsetUserProperty = function (event) {
        if (this.unsetProperties[event.key]) {
            return;
        }
        else {
            this.unsetProperties[event.key] = 'unset';
            delete this.setProperties[event.key];
        }
        this.analyticsProvider.unsetUserProperty(event);
    };
    return SessionAnalyticsProvider;
}());

var SessionExposureTrackingProvider = /** @class */ (function () {
    function SessionExposureTrackingProvider(exposureTrackingProvider) {
        this.tracked = {};
        this.exposureTrackingProvider = exposureTrackingProvider;
    }
    SessionExposureTrackingProvider.prototype.track = function (exposure) {
        var trackedExposure = this.tracked[exposure.flag_key];
        if (trackedExposure && trackedExposure.variant === exposure.variant) {
            return;
        }
        else {
            this.tracked[exposure.flag_key] = exposure;
            this.exposureTrackingProvider.track(exposure);
        }
    };
    return SessionExposureTrackingProvider;
}());

/**
 * @packageDocumentation
 * @module experiment-js-client
 */
// Configs which have been removed from the public API.
// May be added back in the future.
var fetchBackoffTimeout = 10000;
var fetchBackoffAttempts = 8;
var fetchBackoffMinMillis = 500;
var fetchBackoffMaxMillis = 10000;
var fetchBackoffScalar = 1.5;
var minFlagPollerIntervalMillis = 60000;
var euServerUrl = 'https://api.lab.eu.amplitude.com';
var euFlagsServerUrl = 'https://flag.lab.eu.amplitude.com';
/**
 * The default {@link Client} used to fetch variations from Experiment's
 * servers.
 *
 * @category Core Usage
 */
var ExperimentClient = /** @class */ (function () {
    /**
     * Creates a new ExperimentClient instance.
     *
     * In most cases you will want to use the `initialize` factory method in
     * {@link Experiment}.
     *
     * @param apiKey The Client key for the Experiment project
     * @param config See {@link ExperimentConfig} for config options
     */
    function ExperimentClient(apiKey, config) {
        var _this = this;
        var _a, _b, _c, _d;
        this.engine = new EvaluationEngine();
        this.isRunning = false;
        this.apiKey = apiKey;
        // Filter out null/undefined values from config to ensure defaults take precedence
        config = filterNullUndefined(config);
        // Merge configs with defaults and wrap providers
        this.config = __assign(__assign(__assign({}, Defaults), config), { 
            // Set server URLs separately
            serverUrl: (config === null || config === void 0 ? void 0 : config.serverUrl) ||
                (((_a = config === null || config === void 0 ? void 0 : config.serverZone) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'eu'
                    ? euServerUrl
                    : Defaults.serverUrl), flagsServerUrl: (config === null || config === void 0 ? void 0 : config.flagsServerUrl) ||
                (((_b = config === null || config === void 0 ? void 0 : config.serverZone) === null || _b === void 0 ? void 0 : _b.toLowerCase()) === 'eu'
                    ? euFlagsServerUrl
                    : Defaults.flagsServerUrl), 
            // Force minimum flag config polling interval.
            flagConfigPollingIntervalMillis: config.flagConfigPollingIntervalMillis < minFlagPollerIntervalMillis
                ? minFlagPollerIntervalMillis
                : (_c = config.flagConfigPollingIntervalMillis) !== null && _c !== void 0 ? _c : Defaults.flagConfigPollingIntervalMillis });
        var internalInstanceName = (_d = this.config) === null || _d === void 0 ? void 0 : _d['internalInstanceNameSuffix'];
        this.isWebExperiment = internalInstanceName === 'web';
        this.poller = new Poller(function () { return _this.doFlags(); }, this.config.flagConfigPollingIntervalMillis);
        // Transform initialVariants
        if (this.config.initialVariants) {
            for (var flagKey in this.config.initialVariants) {
                this.config.initialVariants[flagKey] = transformVariantFromStorage(this.config.initialVariants[flagKey]);
            }
        }
        if (this.config.userProvider) {
            this.userProvider = this.config.userProvider;
        }
        if (this.config.analyticsProvider) {
            this.analyticsProvider = new SessionAnalyticsProvider(this.config.analyticsProvider);
        }
        if (this.config.exposureTrackingProvider) {
            this.exposureTrackingProvider = new SessionExposureTrackingProvider(this.config.exposureTrackingProvider);
        }
        this.integrationManager = new IntegrationManager(this.config, this);
        // Setup Remote APIs
        var httpClient = new WrapperClient(this.config.httpClient || FetchHttpClient);
        this.flagApi = new SdkFlagApi(this.apiKey, this.config.flagsServerUrl, httpClient);
        this.evaluationApi = new SdkEvaluationApi(this.apiKey, this.config.serverUrl, httpClient);
        // Storage & Caching
        var storage;
        var storageInstanceName = internalInstanceName
            ? "".concat(this.config.instanceName, "-").concat(internalInstanceName)
            : this.config.instanceName;
        if (this.isWebExperiment) {
            storage = new SessionStorage();
        }
        else {
            storage = new LocalStorage();
        }
        this.variants = getVariantStorage(this.apiKey, storageInstanceName, storage);
        this.flags = getFlagStorage(this.apiKey, storageInstanceName, storage);
        try {
            this.flags.load();
            this.variants.load();
        }
        catch (e) {
            // catch localStorage undefined error
        }
        this.mergeInitialFlagsWithStorage();
    }
    /**
     * Start the SDK by getting flag configurations from the server and fetching
     * variants for the user. The promise returned by this function resolves when
     * local flag configurations have been updated, and the {@link fetch()}
     * result has been received (if the request was made).
     *
     * To force this function not to fetch variants, set the {@link fetchOnStart}
     * configuration option to `false` when initializing the SDK.
     *
     * Finally, this function will start polling for flag configurations at a
     * fixed interval. To disable polling, set the {@link pollOnStart}
     * configuration option to `false` on initialization.
     *
     * @param user The user to set in the SDK.
     * @see fetchOnStart
     * @see pollOnStart
     * @see fetch
     * @see variant
     */
    ExperimentClient.prototype.start = function (user) {
        return __awaiter(this, void 0, void 0, function () {
            var flagsReadyPromise, fetchOnStart, e_1;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (this.isRunning) {
                            return [2 /*return*/];
                        }
                        else {
                            this.isRunning = true;
                        }
                        this.setUser(user);
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 6, , 7]);
                        flagsReadyPromise = this.doFlags();
                        fetchOnStart = (_a = this.config.fetchOnStart) !== null && _a !== void 0 ? _a : true;
                        if (!fetchOnStart) return [3 /*break*/, 3];
                        return [4 /*yield*/, Promise.all([this.fetch(user), flagsReadyPromise])];
                    case 2:
                        _b.sent();
                        return [3 /*break*/, 5];
                    case 3: return [4 /*yield*/, flagsReadyPromise];
                    case 4:
                        _b.sent();
                        _b.label = 5;
                    case 5: return [3 /*break*/, 7];
                    case 6:
                        e_1 = _b.sent();
                        // If throwOnError is true, rethrow the error
                        if (this.config.throwOnError) {
                            throw e_1;
                        }
                        return [3 /*break*/, 7];
                    case 7:
                        if (this.config.pollOnStart) {
                            this.poller.start();
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Stop the local flag configuration poller.
     */
    ExperimentClient.prototype.stop = function () {
        if (!this.isRunning) {
            return;
        }
        this.poller.stop();
        this.isRunning = false;
    };
    /**
     * Assign the given user to the SDK and asynchronously fetch all variants
     * from the server. Subsequent calls may omit the user from the argument to
     * use the user from the previous call.
     *
     * If an {@link ExperimentUserProvider} has been set, the argument user will
     * be merged with the provider user, preferring user fields from the argument
     * user and falling back on the provider for fields which are null or
     * undefined.
     *
     * If configured, fetch retries the request in the background on failure.
     * Variants received from a successful retry are stored in local storage for
     * access.
     *
     * If you are using the `initialVariants` config option to preload this SDK
     * from the server, you generally do not need to call `fetch`.
     *
     * @param user The user to fetch variants for.
     * @param options Options for this specific fetch call.
     * @returns Promise that resolves when the request for variants completes.
     * @see ExperimentUser
     * @see ExperimentUserProvider
     * @see FetchOptions
     */
    ExperimentClient.prototype.fetch = function () {
        return __awaiter(this, arguments, void 0, function (user, options) {
            var e_2;
            if (user === void 0) { user = this.user; }
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.setUser(user || {});
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.fetchInternal(user, this.config.fetchTimeoutMillis, this.config.retryFetchOnFailure, options)];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        e_2 = _a.sent();
                        // If throwOnError is configured to true, rethrow the error
                        if (this.config.throwOnError) {
                            throw e_2;
                        }
                        // Otherwise, handle errors silently as before
                        if (this.config.debug) {
                            if (e_2 instanceof TimeoutError) {
                                console.debug(e_2);
                            }
                            else {
                                console.error(e_2);
                            }
                        }
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/, this];
                }
            });
        });
    };
    /**
     * Returns the variant for the provided key.
     *
     * Access the variant from {@link Source}, falling back  on the given
     * fallback, then the configured fallbackVariant.
     *
     * If an {@link ExposureTrackingProvider} is configured and the
     * {@link automaticExposureTracking} configuration option is `true`, this
     * function will call the provider with an {@link Exposure} event. The
     * exposure event does not count towards your event volume within Amplitude.
     *
     * @param key The key to get the variant for.
     * @param fallback The highest priority fallback.
     * @see ExperimentConfig
     * @see ExposureTrackingProvider
     */
    ExperimentClient.prototype.variant = function (key, fallback) {
        var _a, _b;
        if (!this.apiKey) {
            return { value: undefined };
        }
        var sourceVariant = this.variantAndSource(key, fallback);
        if (this.config.automaticExposureTracking) {
            this.exposureInternal(key, sourceVariant);
        }
        this.debug("[Experiment] variant for ".concat(key, " is ").concat(((_a = sourceVariant.variant) === null || _a === void 0 ? void 0 : _a.key) || ((_b = sourceVariant.variant) === null || _b === void 0 ? void 0 : _b.value)));
        return sourceVariant.variant || {};
    };
    /**
     * Track an exposure event for the variant associated with the flag/experiment
     * {@link key}.
     *
     * This method requires that an {@link ExposureTrackingProvider} be
     * configured when this client is initialized, either manually, or through the
     * Amplitude Analytics SDK integration from set up using
     * {@link Experiment.initializeWithAmplitudeAnalytics}.
     *
     * @param key The flag/experiment key to track an exposure for.
     * @see ExposureTrackingProvider
     */
    ExperimentClient.prototype.exposure = function (key) {
        var sourceVariant = this.variantAndSource(key);
        this.exposureInternal(key, sourceVariant);
    };
    /**
     * Returns all variants for the user.
     *
     * The primary source of variants is based on the
     * {@link Source} configured in the {@link ExperimentConfig}.
     *
     * @see Source
     * @see ExperimentConfig
     */
    ExperimentClient.prototype.all = function () {
        if (!this.apiKey) {
            return {};
        }
        var evaluatedVariants = this.evaluate();
        for (var flagKey in evaluatedVariants) {
            var flag = this.flags.get(flagKey);
            if (!isLocalEvaluationMode(flag)) {
                delete evaluatedVariants[flagKey];
            }
        }
        return __assign(__assign(__assign({}, this.secondaryVariants()), this.sourceVariants()), evaluatedVariants);
    };
    /**
     * Clear all variants in the cache and storage.
     */
    ExperimentClient.prototype.clear = function () {
        this.variants.clear();
        try {
            void this.variants.store();
        }
        catch (e) {
            // catch localStorage undefined error
        }
    };
    /**
     * Get a copy of the internal {@link ExperimentUser} object if it is set.
     *
     * @returns a copy of the internal user object if set.
     */
    ExperimentClient.prototype.getUser = function () {
        var _a;
        if (!this.user) {
            return this.user;
        }
        if ((_a = this.user) === null || _a === void 0 ? void 0 : _a.user_properties) {
            var userPropertiesCopy = __assign({}, this.user.user_properties);
            return __assign(__assign({}, this.user), { user_properties: userPropertiesCopy });
        }
        else {
            return __assign({}, this.user);
        }
    };
    /**
     * Copy in and set the user within the experiment client.
     *
     * @param user the user to set within the experiment client.
     */
    ExperimentClient.prototype.setUser = function (user) {
        var _a;
        if (!user) {
            this.user = null;
            return;
        }
        if ((_a = this.user) === null || _a === void 0 ? void 0 : _a.user_properties) {
            var userPropertiesCopy = __assign({}, user.user_properties);
            this.user = __assign(__assign({}, user), { user_properties: userPropertiesCopy });
        }
        else {
            this.user = __assign({}, user);
        }
    };
    /**
     * Get the user provider set by {@link setUserProvider} or null if the user
     * provider has not been set.
     *
     * @returns The user provider set by {@link setUserProvider} or null.
     * @deprecated use ExperimentConfig.userProvider instead
     */
    ExperimentClient.prototype.getUserProvider = function () {
        return this.userProvider;
    };
    /**
     * Sets a user provider that will inject identity information into the user
     * for {@link fetch()} requests. The user provider will only set user fields
     * in outgoing requests which are null or undefined.
     *
     * See {@link ExperimentUserProvider} for more details
     * @param userProvider
     * @deprecated use ExperimentConfig.userProvider instead
     */
    ExperimentClient.prototype.setUserProvider = function (userProvider) {
        this.userProvider = userProvider;
        return this;
    };
    ExperimentClient.prototype.mergeInitialFlagsWithStorage = function () {
        var _this = this;
        if (this.config.initialFlags) {
            var initialFlags = JSON.parse(this.config.initialFlags);
            initialFlags.forEach(function (flag) {
                if (!_this.flags.get(flag.key)) {
                    _this.flags.put(flag.key, flag);
                }
            });
        }
    };
    ExperimentClient.prototype.evaluate = function (flagKeys) {
        var e_3, _a;
        var user = this.addContext(this.user);
        var flags = topologicalSort(this.flags.getAll(), flagKeys);
        var context = convertUserToContext(user);
        var evaluationVariants = this.engine.evaluate(context, flags);
        var variants = {};
        try {
            for (var _b = __values(Object.keys(evaluationVariants)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var flagKey = _c.value;
                variants[flagKey] = convertEvaluationVariantToVariant(evaluationVariants[flagKey]);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return variants;
    };
    ExperimentClient.prototype.variantAndSource = function (key, fallback) {
        var sourceVariant = {};
        if (this.config.source === Source.LocalStorage) {
            sourceVariant = this.localStorageVariantAndSource(key, fallback);
        }
        else if (this.config.source === Source.InitialVariants) {
            sourceVariant = this.initialVariantsVariantAndSource(key, fallback);
        }
        var flag = this.flags.get(key);
        if (isLocalEvaluationMode(flag) || (!sourceVariant.variant && flag)) {
            sourceVariant = this.localEvaluationVariantAndSource(key, flag, fallback);
        }
        return sourceVariant;
    };
    /**
     * This function assumes the flag exists and is local evaluation mode. For
     * local evaluation, fallback order goes:
     *
     *  1. Local evaluation
     *  2. Inline function fallback
     *  3. Initial variants
     *  4. Config fallback
     *
     * If there is a default variant and no fallback, return the default variant.
     */
    ExperimentClient.prototype.localEvaluationVariantAndSource = function (key, flag, fallback) {
        var _a;
        var defaultSourceVariant = {};
        // Local evaluation
        var variant = this.evaluate([flag.key])[key];
        var source = VariantSource.LocalEvaluation;
        var isLocalEvaluationDefault = (_a = variant === null || variant === void 0 ? void 0 : variant.metadata) === null || _a === void 0 ? void 0 : _a.default;
        if (!isNullOrUndefined(variant) && !isLocalEvaluationDefault) {
            return {
                variant: convertVariant(variant),
                source: source,
                hasDefaultVariant: false,
            };
        }
        else if (isLocalEvaluationDefault) {
            defaultSourceVariant = {
                variant: convertVariant(variant),
                source: source,
                hasDefaultVariant: true,
            };
        }
        // Inline fallback
        if (!isNullOrUndefined(fallback)) {
            return {
                variant: convertVariant(fallback),
                source: VariantSource.FallbackInline,
                hasDefaultVariant: defaultSourceVariant.hasDefaultVariant,
            };
        }
        // Initial variants
        var initialVariant = this.config.initialVariants[key];
        if (!isNullOrUndefined(initialVariant)) {
            return {
                variant: convertVariant(initialVariant),
                source: VariantSource.SecondaryInitialVariants,
                hasDefaultVariant: defaultSourceVariant.hasDefaultVariant,
            };
        }
        // Configured fallback, or default variant
        var fallbackVariant = convertVariant(this.config.fallbackVariant);
        var fallbackSourceVariant = {
            variant: fallbackVariant,
            source: VariantSource.FallbackConfig,
            hasDefaultVariant: defaultSourceVariant.hasDefaultVariant,
        };
        if (!isNullUndefinedOrEmpty(fallbackVariant)) {
            return fallbackSourceVariant;
        }
        return defaultSourceVariant;
    };
    /**
     * For Source.LocalStorage, fallback order goes:
     *
     *  1. Local Storage
     *  2. Inline function fallback
     *  3. InitialFlags
     *  4. Config fallback
     *
     * If there is a default variant and no fallback, return the default variant.
     */
    ExperimentClient.prototype.localStorageVariantAndSource = function (key, fallback) {
        var _a;
        var defaultSourceVariant = {};
        // Local storage
        var localStorageVariant = this.variants.get(key);
        var isLocalStorageDefault = (_a = localStorageVariant === null || localStorageVariant === void 0 ? void 0 : localStorageVariant.metadata) === null || _a === void 0 ? void 0 : _a.default;
        if (!isNullOrUndefined(localStorageVariant) && !isLocalStorageDefault) {
            return {
                variant: convertVariant(localStorageVariant),
                source: VariantSource.LocalStorage,
                hasDefaultVariant: false,
            };
        }
        else if (isLocalStorageDefault) {
            defaultSourceVariant = {
                variant: convertVariant(localStorageVariant),
                source: VariantSource.LocalStorage,
                hasDefaultVariant: true,
            };
        }
        // Inline fallback
        if (!isNullOrUndefined(fallback)) {
            return {
                variant: convertVariant(fallback),
                source: VariantSource.FallbackInline,
                hasDefaultVariant: defaultSourceVariant.hasDefaultVariant,
            };
        }
        // Initial variants
        var initialVariant = this.config.initialVariants[key];
        if (!isNullOrUndefined(initialVariant)) {
            return {
                variant: convertVariant(initialVariant),
                source: VariantSource.SecondaryInitialVariants,
                hasDefaultVariant: defaultSourceVariant.hasDefaultVariant,
            };
        }
        // Configured fallback, or default variant
        var fallbackVariant = convertVariant(this.config.fallbackVariant);
        var fallbackSourceVariant = {
            variant: fallbackVariant,
            source: VariantSource.FallbackConfig,
            hasDefaultVariant: defaultSourceVariant.hasDefaultVariant,
        };
        if (!isNullUndefinedOrEmpty(fallbackVariant)) {
            return fallbackSourceVariant;
        }
        return defaultSourceVariant;
    };
    /**
     * For Source.InitialVariants, fallback order goes:
     *
     *  1. Initial variants
     *  2. Local storage
     *  3. Inline function fallback
     *  4. Config fallback
     *
     * If there is a default variant and no fallback, return the default variant.
     */
    ExperimentClient.prototype.initialVariantsVariantAndSource = function (key, fallback) {
        var _a;
        var defaultSourceVariant = {};
        // Initial variants
        var initialVariantsVariant = this.config.initialVariants[key];
        if (!isNullOrUndefined(initialVariantsVariant)) {
            return {
                variant: convertVariant(initialVariantsVariant),
                source: VariantSource.InitialVariants,
                hasDefaultVariant: false,
            };
        }
        // Local storage
        var localStorageVariant = this.variants.get(key);
        var isLocalStorageDefault = (_a = localStorageVariant === null || localStorageVariant === void 0 ? void 0 : localStorageVariant.metadata) === null || _a === void 0 ? void 0 : _a.default;
        if (!isNullOrUndefined(localStorageVariant) && !isLocalStorageDefault) {
            return {
                variant: convertVariant(localStorageVariant),
                source: VariantSource.LocalStorage,
                hasDefaultVariant: false,
            };
        }
        else if (isLocalStorageDefault) {
            defaultSourceVariant = {
                variant: convertVariant(localStorageVariant),
                source: VariantSource.LocalStorage,
                hasDefaultVariant: true,
            };
        }
        // Inline fallback
        if (!isNullOrUndefined(fallback)) {
            return {
                variant: convertVariant(fallback),
                source: VariantSource.FallbackInline,
                hasDefaultVariant: defaultSourceVariant.hasDefaultVariant,
            };
        }
        // Configured fallback, or default variant
        var fallbackVariant = convertVariant(this.config.fallbackVariant);
        var fallbackSourceVariant = {
            variant: fallbackVariant,
            source: VariantSource.FallbackConfig,
            hasDefaultVariant: defaultSourceVariant.hasDefaultVariant,
        };
        if (!isNullUndefinedOrEmpty(fallbackVariant)) {
            return fallbackSourceVariant;
        }
        return defaultSourceVariant;
    };
    ExperimentClient.prototype.fetchInternal = function (user, timeoutMillis, retry, options) {
        return __awaiter(this, void 0, void 0, function () {
            var variants, e_4;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // Don't even try to fetch variants if API key is not set
                        if (!this.apiKey) {
                            throw Error('Experiment API key is empty');
                        }
                        this.debug("[Experiment] Fetch all: retry=".concat(retry));
                        // Proactively cancel retries if active in order to avoid unnecessary API
                        // requests. A new failure will restart the retries.
                        if (retry) {
                            this.stopRetries();
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 4, , 5]);
                        return [4 /*yield*/, this.doFetch(user, timeoutMillis, options)];
                    case 2:
                        variants = _a.sent();
                        return [4 /*yield*/, this.storeVariants(variants, options)];
                    case 3:
                        _a.sent();
                        return [2 /*return*/, variants];
                    case 4:
                        e_4 = _a.sent();
                        if (retry && this.shouldRetryFetch(e_4)) {
                            void this.startRetries(user, options);
                        }
                        throw e_4;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    ExperimentClient.prototype.cleanUserPropsForFetch = function (user) {
        var cleanedUser = __assign({}, user);
        delete cleanedUser.cookie;
        return cleanedUser;
    };
    ExperimentClient.prototype.doFetch = function (user, timeoutMillis, options) {
        return __awaiter(this, void 0, void 0, function () {
            var results, variants, _a, _b, key;
            var e_5, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0: return [4 /*yield*/, this.addContextOrWait(user)];
                    case 1:
                        user = _d.sent();
                        user = this.cleanUserPropsForFetch(user);
                        this.debug('[Experiment] Fetch variants for user: ', user);
                        return [4 /*yield*/, this.evaluationApi.getVariants(user, __assign({ timeoutMillis: timeoutMillis }, options))];
                    case 2:
                        results = _d.sent();
                        variants = {};
                        try {
                            for (_a = __values(Object.keys(results)), _b = _a.next(); !_b.done; _b = _a.next()) {
                                key = _b.value;
                                variants[key] = convertEvaluationVariantToVariant(results[key]);
                            }
                        }
                        catch (e_5_1) { e_5 = { error: e_5_1 }; }
                        finally {
                            try {
                                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                            }
                            finally { if (e_5) throw e_5.error; }
                        }
                        this.debug('[Experiment] Received variants: ', variants);
                        return [2 /*return*/, variants];
                }
            });
        });
    };
    ExperimentClient.prototype.doFlags = function () {
        return __awaiter(this, void 0, void 0, function () {
            var user, flags, e_6;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 4, , 5]);
                        user = void 0;
                        if (!this.isWebExperiment) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.addContextOrWait(this.getUser())];
                    case 1:
                        user = _a.sent();
                        _a.label = 2;
                    case 2: return [4 /*yield*/, this.flagApi.getFlags({
                            libraryName: 'experiment-js-client',
                            libraryVersion: version,
                            timeoutMillis: this.config.fetchTimeoutMillis,
                            deliveryMethod: this.isWebExperiment ? 'web' : undefined,
                            user: (user === null || user === void 0 ? void 0 : user.user_id) || (user === null || user === void 0 ? void 0 : user.device_id)
                                ? { user_id: user === null || user === void 0 ? void 0 : user.user_id, device_id: user === null || user === void 0 ? void 0 : user.device_id }
                                : undefined,
                        })];
                    case 3:
                        flags = _a.sent();
                        this.flags.clear();
                        this.flags.putAll(flags);
                        return [3 /*break*/, 5];
                    case 4:
                        e_6 = _a.sent();
                        if (e_6 instanceof TimeoutError) {
                            this.config.debug && console.debug(e_6);
                            // If throwOnError is configured to true, rethrow timeout errors
                            if (this.config.throwOnError) {
                                throw e_6;
                            }
                        }
                        else {
                            throw e_6;
                        }
                        return [3 /*break*/, 5];
                    case 5:
                        try {
                            this.flags.store();
                        }
                        catch (e) {
                            // catch localStorage undefined error
                        }
                        this.mergeInitialFlagsWithStorage();
                        return [2 /*return*/];
                }
            });
        });
    };
    ExperimentClient.prototype.storeVariants = function (variants, options) {
        return __awaiter(this, void 0, void 0, function () {
            var failedFlagKeys, _loop_1, this_1, key, key;
            return __generator(this, function (_a) {
                failedFlagKeys = options && options.flagKeys ? options.flagKeys : [];
                if (failedFlagKeys.length === 0) {
                    this.variants.clear();
                }
                _loop_1 = function (key) {
                    failedFlagKeys = failedFlagKeys.filter(function (flagKey) { return flagKey !== key; });
                    this_1.variants.put(key, variants[key]);
                };
                this_1 = this;
                for (key in variants) {
                    _loop_1(key);
                }
                for (key in failedFlagKeys) {
                    this.variants.remove(key);
                }
                try {
                    this.variants.store();
                }
                catch (e) {
                    // catch localStorage undefined error
                }
                this.debug('[Experiment] Stored variants: ', variants);
                return [2 /*return*/];
            });
        });
    };
    ExperimentClient.prototype.startRetries = function (user, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                this.debug('[Experiment] Retry fetch');
                this.retriesBackoff = new Backoff(fetchBackoffAttempts, fetchBackoffMinMillis, fetchBackoffMaxMillis, fetchBackoffScalar);
                void this.retriesBackoff.start(function () { return __awaiter(_this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.fetchInternal(user, fetchBackoffTimeout, false, options)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                }); });
                return [2 /*return*/];
            });
        });
    };
    ExperimentClient.prototype.stopRetries = function () {
        if (this.retriesBackoff) {
            this.retriesBackoff.cancel();
        }
    };
    ExperimentClient.prototype.addContext = function (user) {
        var _a;
        var providedUser = (_a = this.userProvider) === null || _a === void 0 ? void 0 : _a.getUser();
        var integrationUser = this.integrationManager.getUser();
        var mergedUserProperties = __assign(__assign(__assign({}, providedUser === null || providedUser === void 0 ? void 0 : providedUser.user_properties), integrationUser.user_properties), user === null || user === void 0 ? void 0 : user.user_properties);
        return __assign(__assign(__assign(__assign({ library: "experiment-js-client/".concat(version) }, providedUser), integrationUser), user), { user_properties: mergedUserProperties });
    };
    ExperimentClient.prototype.addContextOrWait = function (user) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.integrationManager.ready()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, this.addContext(user)];
                }
            });
        });
    };
    ExperimentClient.prototype.sourceVariants = function () {
        if (this.config.source == Source.LocalStorage) {
            return this.variants.getAll();
        }
        else if (this.config.source == Source.InitialVariants) {
            return this.config.initialVariants;
        }
    };
    ExperimentClient.prototype.secondaryVariants = function () {
        if (this.config.source == Source.LocalStorage) {
            return this.config.initialVariants;
        }
        else if (this.config.source == Source.InitialVariants) {
            return this.variants.getAll();
        }
    };
    ExperimentClient.prototype.exposureInternal = function (key, sourceVariant) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        // Variant metadata may disable exposure tracking remotely.
        var trackExposure = (_c = (_b = (_a = sourceVariant.variant) === null || _a === void 0 ? void 0 : _a.metadata) === null || _b === void 0 ? void 0 : _b.trackExposure) !== null && _c !== void 0 ? _c : true;
        if (!trackExposure) {
            return;
        }
        this.legacyExposureInternal(key, sourceVariant.variant, sourceVariant.source);
        var exposure = { flag_key: key };
        // Do not track exposure for fallback variants that are not associated with
        // a default variant.
        var fallback = isFallback(sourceVariant.source);
        if (fallback && !sourceVariant.hasDefaultVariant) {
            return;
        }
        if ((_d = sourceVariant.variant) === null || _d === void 0 ? void 0 : _d.expKey) {
            exposure.experiment_key = (_e = sourceVariant.variant) === null || _e === void 0 ? void 0 : _e.expKey;
        }
        var metadata = (_f = sourceVariant.variant) === null || _f === void 0 ? void 0 : _f.metadata;
        if (!fallback && !(metadata === null || metadata === void 0 ? void 0 : metadata.default)) {
            if ((_g = sourceVariant.variant) === null || _g === void 0 ? void 0 : _g.key) {
                exposure.variant = sourceVariant.variant.key;
            }
            else if ((_h = sourceVariant.variant) === null || _h === void 0 ? void 0 : _h.value) {
                exposure.variant = sourceVariant.variant.value;
            }
        }
        if (metadata)
            exposure.metadata = metadata;
        // Add current URL for web experiments
        if (this.isWebExperiment) {
            var globalScope = getGlobalScope();
            if (globalScope === null || globalScope === void 0 ? void 0 : globalScope.location) {
                try {
                    var url = globalScope.location.href;
                    // Add URL without query parameters
                    exposure.metadata.url = url.split('?')[0] || '';
                }
                catch (e) {
                    // If there's any error getting the URL, continue without it
                }
            }
        }
        (_j = this.exposureTrackingProvider) === null || _j === void 0 ? void 0 : _j.track(exposure);
        this.integrationManager.track(exposure);
    };
    ExperimentClient.prototype.legacyExposureInternal = function (key, variant, source) {
        var _a, _b, _c, _d, _e;
        if (this.analyticsProvider) {
            var user = this.addContext(this.getUser());
            var event_1 = exposureEvent(user, key, variant, source);
            if (isFallback(source) || !(variant === null || variant === void 0 ? void 0 : variant.value)) {
                (_b = (_a = this.analyticsProvider) === null || _a === void 0 ? void 0 : _a.unsetUserProperty) === null || _b === void 0 ? void 0 : _b.call(_a, event_1);
            }
            else if (variant === null || variant === void 0 ? void 0 : variant.value) {
                (_d = (_c = this.analyticsProvider) === null || _c === void 0 ? void 0 : _c.setUserProperty) === null || _d === void 0 ? void 0 : _d.call(_c, event_1);
                (_e = this.analyticsProvider) === null || _e === void 0 ? void 0 : _e.track(event_1);
            }
        }
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ExperimentClient.prototype.debug = function (message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
        }
        if (this.config.debug) {
            console.debug.apply(console, __spreadArray([message], __read(optionalParams), false));
        }
    };
    ExperimentClient.prototype.shouldRetryFetch = function (e) {
        if (e instanceof FetchError) {
            return e.statusCode < 400 || e.statusCode >= 500 || e.statusCode === 429;
        }
        return true;
    };
    /**
     * Add a plugin to the experiment client.
     * @param plugin the plugin to add.
     */
    ExperimentClient.prototype.addPlugin = function (plugin) {
        if (plugin.type === 'integration') {
            this.integrationManager.setIntegration(plugin);
        }
    };
    return ExperimentClient;
}());

var DefaultUserProvider = /** @class */ (function () {
    function DefaultUserProvider(userProvider, apiKey) {
        var _a, _b, _c;
        this.globalScope = getGlobalScope();
        this.userAgent = typeof ((_a = this.globalScope) === null || _a === void 0 ? void 0 : _a.navigator) !== 'undefined'
            ? (_b = this.globalScope) === null || _b === void 0 ? void 0 : _b.navigator.userAgent
            : undefined;
        this.ua = new UAParser(this.userAgent).getResult();
        this.localStorage = new LocalStorage();
        this.sessionStorage = new SessionStorage();
        this.userProvider = userProvider;
        this.apiKey = apiKey;
        this.storageKey = "EXP_".concat((_c = this.apiKey) === null || _c === void 0 ? void 0 : _c.slice(0, 10), "_DEFAULT_USER_PROVIDER");
    }
    DefaultUserProvider.prototype.getUser = function () {
        var _a, _b, _c, _d, _e;
        var user = ((_a = this.userProvider) === null || _a === void 0 ? void 0 : _a.getUser()) || {};
        return __assign({ language: this.getLanguage(), platform: 'Web', os: this.getOs(this.ua), device_model: this.getDeviceModel(this.ua), device_category: (_c = (_b = this.ua.device) === null || _b === void 0 ? void 0 : _b.type) !== null && _c !== void 0 ? _c : 'desktop', referring_url: (_e = (_d = this.globalScope) === null || _d === void 0 ? void 0 : _d.document) === null || _e === void 0 ? void 0 : _e.referrer.replace(/\/$/, ''), cookie: this.getCookie(), browser: this.getBrowser(this.ua), landing_url: this.getLandingUrl(), first_seen: this.getFirstSeen(), url_param: this.getUrlParam(), user_agent: this.userAgent }, user);
    };
    DefaultUserProvider.prototype.getLanguage = function () {
        return ((typeof navigator !== 'undefined' &&
            ((navigator.languages && navigator.languages[0]) ||
                navigator.language)) ||
            '');
    };
    DefaultUserProvider.prototype.getOs = function (ua) {
        var _a, _b;
        return [(_a = ua.browser) === null || _a === void 0 ? void 0 : _a.name, (_b = ua.browser) === null || _b === void 0 ? void 0 : _b.major]
            .filter(function (e) { return e !== null && e !== undefined; })
            .join(' ');
    };
    DefaultUserProvider.prototype.getDeviceModel = function (ua) {
        var _a;
        return (_a = ua.os) === null || _a === void 0 ? void 0 : _a.name;
    };
    DefaultUserProvider.prototype.getBrowser = function (ua) {
        var _a;
        var browser = (_a = ua.browser) === null || _a === void 0 ? void 0 : _a.name;
        // Normalize for Chrome, Firefox, Safari, Edge, and Opera.
        if (browser === null || browser === void 0 ? void 0 : browser.includes('Chrom'))
            browser = 'Chrome'; // Chrome, Chrome Mobile, Chromium, etc
        if (browser === null || browser === void 0 ? void 0 : browser.includes('Firefox'))
            browser = 'Firefox'; // Firefox, Firefox Mobile, etc
        if (browser === null || browser === void 0 ? void 0 : browser.includes('Safari'))
            browser = 'Safari'; // Safari, Safari Mobile
        if (browser === null || browser === void 0 ? void 0 : browser.includes('Edge'))
            browser = 'Edge'; // Edge
        if (browser === null || browser === void 0 ? void 0 : browser.includes('Opera'))
            browser = 'Opera'; // Opera, Opera Mobi, etc
        return browser;
    };
    DefaultUserProvider.prototype.getCookie = function () {
        var _a, _b, _c, _d, _e;
        if (!((_b = (_a = this.globalScope) === null || _a === void 0 ? void 0 : _a.document) === null || _b === void 0 ? void 0 : _b.cookie)) {
            return undefined;
        }
        return Object.fromEntries((_e = (_d = (_c = this.globalScope) === null || _c === void 0 ? void 0 : _c.document) === null || _d === void 0 ? void 0 : _d.cookie) === null || _e === void 0 ? void 0 : _e.split('; ').map(function (c) { return c.split('='); }));
    };
    DefaultUserProvider.prototype.getLandingUrl = function () {
        var _a, _b;
        try {
            var sessionUser = JSON.parse(this.sessionStorage.get(this.storageKey) || '{}');
            if (!sessionUser.landing_url) {
                sessionUser.landing_url = (_b = (_a = this.globalScope) === null || _a === void 0 ? void 0 : _a.location) === null || _b === void 0 ? void 0 : _b.href.replace(/\/$/, '');
                this.sessionStorage.put(this.storageKey, JSON.stringify(sessionUser));
            }
            return sessionUser.landing_url;
        }
        catch (_c) {
            return undefined;
        }
    };
    DefaultUserProvider.prototype.getFirstSeen = function () {
        try {
            var localUser = JSON.parse(this.localStorage.get(this.storageKey) || '{}');
            if (!localUser.first_seen) {
                localUser.first_seen = (Date.now() / 1000).toString();
                this.localStorage.put(this.storageKey, JSON.stringify(localUser));
            }
            return localUser.first_seen;
        }
        catch (_a) {
            return undefined;
        }
    };
    DefaultUserProvider.prototype.getUrlParam = function () {
        var e_1, _a;
        var _b;
        if (!this.globalScope) {
            return undefined;
        }
        var params = {};
        try {
            var url = new URL(this.globalScope.location.href);
            try {
                for (var _c = __values(url.searchParams), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var _e = __read(_d.value, 2), name_1 = _e[0], value = _e[1];
                    params[name_1] = __spreadArray(__spreadArray([], __read(((_b = params[name_1]) !== null && _b !== void 0 ? _b : [])), false), __read(value.split(',')), false);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        catch (error) {
            return undefined;
        }
        return Object.entries(params).reduce(function (acc, _a) {
            var _b = __read(_a, 2), name = _b[0], value = _b[1];
            acc[name] = value.length == 1 ? value[0] : value;
            return acc;
        }, {});
    };
    return DefaultUserProvider;
}());

// Global instances for debugging.
safeGlobal.experimentInstances = {};
var instances = safeGlobal.experimentInstances;
/**
 * Initializes a singleton {@link ExperimentClient} identified by the configured
 * instance name.
 *
 * @param apiKey The deployment API Key
 * @param config See {@link ExperimentConfig} for config options
 */
var initialize = function (apiKey, config) {
    return _initialize(apiKey, config);
};
/**
 * Initialize a singleton {@link ExperimentClient} which automatically
 * integrates with the installed and initialized instance of the amplitude
 * analytics SDK.
 *
 * You must be using amplitude-js SDK version 8.17.0+ for this integration to
 * work.
 *
 * @param apiKey The deployment API Key
 * @param config See {@link ExperimentConfig} for config options
 */
var initializeWithAmplitudeAnalytics = function (apiKey, config) {
    var plugin = function () {
        return new AmplitudeIntegrationPlugin(apiKey, AnalyticsConnector.getInstance(getInstanceName(config)), 10000);
    };
    return _initialize(apiKey, config, plugin);
};
var getInstanceName = function (config) {
    return (config === null || config === void 0 ? void 0 : config.instanceName) || Defaults.instanceName;
};
var getInstanceKey = function (apiKey, config) {
    // Store instances by appending the instance name and api key. Allows for
    // initializing multiple default instances for different api keys.
    var instanceName = getInstanceName(config);
    // The internal instance name prefix is used by web experiment to differentiate
    // web and feature experiment sdks which use the same api key.
    var internalInstanceNameSuffix = config === null || config === void 0 ? void 0 : config['internalInstanceNameSuffix'];
    return internalInstanceNameSuffix
        ? "".concat(instanceName, ".").concat(apiKey, ".").concat(internalInstanceNameSuffix)
        : "".concat(instanceName, ".").concat(apiKey);
};
var newExperimentClient = function (apiKey, config) {
    return new ExperimentClient(apiKey, __assign(__assign({}, config), { userProvider: new DefaultUserProvider(config === null || config === void 0 ? void 0 : config.userProvider, apiKey) }));
};
var _initialize = function (apiKey, config, plugin) {
    var instanceKey = getInstanceKey(apiKey, config);
    var client = instances[instanceKey];
    if (client) {
        return client;
    }
    client = newExperimentClient(apiKey, config);
    if (plugin) {
        client.addPlugin(plugin());
    }
    instances[instanceKey] = client;
    return client;
};
/**
 * Provides factory methods for storing singleton instances of {@link ExperimentClient}
 * @category Core Usage
 */
var Experiment = {
    initialize: initialize,
    initializeWithAmplitudeAnalytics: initializeWithAmplitudeAnalytics,
};

/**
 * A stub {@link Client} implementation that does nothing for all methods
 */
var StubExperimentClient = /** @class */ (function () {
    function StubExperimentClient() {
    }
    StubExperimentClient.prototype.getUser = function () {
        return {};
    };
    StubExperimentClient.prototype.start = function (user) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/];
            });
        });
    };
    StubExperimentClient.prototype.stop = function () { };
    StubExperimentClient.prototype.setUser = function (user) { };
    StubExperimentClient.prototype.fetch = function (user, options) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this];
            });
        });
    };
    StubExperimentClient.prototype.getUserProvider = function () {
        return null;
    };
    StubExperimentClient.prototype.setUserProvider = function (uerProvider) {
        return this;
    };
    StubExperimentClient.prototype.variant = function (key, fallback) {
        return Defaults.fallbackVariant;
    };
    StubExperimentClient.prototype.all = function () {
        return {};
    };
    StubExperimentClient.prototype.clear = function () { };
    StubExperimentClient.prototype.exposure = function (key) { };
    return StubExperimentClient;
}());

export { AmplitudeAnalyticsProvider, AmplitudeIntegrationPlugin, AmplitudeUserProvider, Experiment, ExperimentClient, Source, StubExperimentClient, initialize, initializeWithAmplitudeAnalytics };
