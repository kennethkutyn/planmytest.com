import { safeGlobal, TimeoutError, isLocalStorageAvailable, getGlobalScope, EvaluationEngine, Poller, SdkFlagApi, SdkEvaluationApi, topologicalSort, FetchError } from '@amplitude/experiment-core';
import { AnalyticsConnector } from '@amplitude/analytics-connector';
import { UAParser } from '@amplitude/ua-parser-js';

/**
 * @deprecated Update your version of the amplitude analytics-js SDK to 8.17.0+ and for seamless
 * integration with the amplitude analytics SDK.
 */
class AmplitudeUserProvider {
    constructor(amplitudeInstance) {
        this.amplitudeInstance = amplitudeInstance;
    }
    getUser() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        return {
            device_id: (_b = (_a = this.amplitudeInstance) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.deviceId,
            user_id: (_d = (_c = this.amplitudeInstance) === null || _c === void 0 ? void 0 : _c.options) === null || _d === void 0 ? void 0 : _d.userId,
            version: (_f = (_e = this.amplitudeInstance) === null || _e === void 0 ? void 0 : _e.options) === null || _f === void 0 ? void 0 : _f.versionName,
            language: (_h = (_g = this.amplitudeInstance) === null || _g === void 0 ? void 0 : _g.options) === null || _h === void 0 ? void 0 : _h.language,
            platform: (_k = (_j = this.amplitudeInstance) === null || _j === void 0 ? void 0 : _j.options) === null || _k === void 0 ? void 0 : _k.platform,
            os: this.getOs(),
            device_model: this.getDeviceModel(),
        };
    }
    getOs() {
        var _a, _b, _c, _d, _e, _f;
        return [
            (_c = (_b = (_a = this.amplitudeInstance) === null || _a === void 0 ? void 0 : _a._ua) === null || _b === void 0 ? void 0 : _b.browser) === null || _c === void 0 ? void 0 : _c.name,
            (_f = (_e = (_d = this.amplitudeInstance) === null || _d === void 0 ? void 0 : _d._ua) === null || _e === void 0 ? void 0 : _e.browser) === null || _f === void 0 ? void 0 : _f.major,
        ]
            .filter((e) => e !== null && e !== undefined)
            .join(' ');
    }
    getDeviceModel() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.amplitudeInstance) === null || _a === void 0 ? void 0 : _a._ua) === null || _b === void 0 ? void 0 : _b.os) === null || _c === void 0 ? void 0 : _c.name;
    }
}
/**
 * @deprecated Update your version of the amplitude analytics-js SDK to 8.17.0+ and for seamless
 * integration with the amplitude analytics SDK.
 */
class AmplitudeAnalyticsProvider {
    constructor(amplitudeInstance) {
        this.amplitudeInstance = amplitudeInstance;
    }
    track(event) {
        this.amplitudeInstance.logEvent(event.name, event.properties);
    }
    setUserProperty(event) {
        var _a;
        // if the variant has a value, set the user property and log an event
        this.amplitudeInstance.setUserProperties({
            [event.userProperty]: (_a = event.variant) === null || _a === void 0 ? void 0 : _a.value,
        });
    }
    unsetUserProperty(event) {
        // if the variant does not have a value, unset the user property
        this.amplitudeInstance['_logEvent']('$identify', null, null, {
            $unset: { [event.userProperty]: '-' },
        });
    }
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

const parseAmplitudeCookie = (apiKey, newFormat = false) => {
    // Get the cookie value
    const key = generateKey(apiKey, newFormat);
    let value = undefined;
    const cookies = safeGlobal.document.cookie.split('; ');
    for (const cookie of cookies) {
        const [cookieKey, cookieValue] = cookie.split('=', 2);
        if (cookieKey === key) {
            value = decodeURIComponent(cookieValue);
        }
    }
    if (!value) {
        return;
    }
    // Parse cookie value depending on format
    try {
        // New format
        if (newFormat) {
            const decoding = atob(value);
            return JSON.parse(decodeURIComponent(decoding));
        }
        // Old format
        const values = value.split('.');
        let userId = undefined;
        if (values.length >= 2 && values[1]) {
            userId = atob(values[1]);
        }
        return {
            deviceId: values[0],
            userId,
        };
    }
    catch (e) {
        return;
    }
};
const parseAmplitudeLocalStorage = (apiKey) => {
    const key = generateKey(apiKey, true);
    try {
        const value = safeGlobal.localStorage.getItem(key);
        if (!value)
            return;
        const state = JSON.parse(value);
        if (typeof state !== 'object')
            return;
        return state;
    }
    catch (_a) {
        return;
    }
};
const parseAmplitudeSessionStorage = (apiKey) => {
    const key = generateKey(apiKey, true);
    try {
        const value = safeGlobal.sessionStorage.getItem(key);
        if (!value)
            return;
        const state = JSON.parse(value);
        if (typeof state !== 'object')
            return;
        return state;
    }
    catch (_a) {
        return;
    }
};
const generateKey = (apiKey, newFormat) => {
    if (newFormat) {
        if ((apiKey === null || apiKey === void 0 ? void 0 : apiKey.length) < 10) {
            return;
        }
        return `AMP_${apiKey.substring(0, 10)}`;
    }
    if ((apiKey === null || apiKey === void 0 ? void 0 : apiKey.length) < 6) {
        return;
    }
    return `amp_${apiKey.substring(0, 6)}`;
};

/**
 * Integration plugin for Amplitude Analytics. Uses the analytics connector to
 * track events and get user identity.
 *
 * On initialization, this plugin attempts to read the user identity from all
 * the storage locations and formats supported by the analytics SDK, then
 * commits the identity to the connector. The order of locations checks are:
 *  - Cookie
 *  - Cookie (Legacy)
 *  - Local Storage
 *  - Session Storage
 *
 * Events are tracked only if the connector has an event receiver set, otherwise
 * track returns false, and events are persisted and managed by the
 * IntegrationManager.
 */
class AmplitudeIntegrationPlugin {
    constructor(apiKey, connector, timeoutMillis) {
        this.type = 'integration';
        this.apiKey = apiKey;
        this.identityStore = connector.identityStore;
        this.eventBridge = connector.eventBridge;
        this.contextProvider = connector.applicationContextProvider;
        this.timeoutMillis = timeoutMillis;
        this.loadPersistedState();
        if (timeoutMillis <= 0) {
            this.setup = undefined;
        }
    }
    setup(config, client) {
        return __awaiter(this, void 0, void 0, function* () {
            // Setup automatic fetch on amplitude identity change.
            if (config === null || config === void 0 ? void 0 : config.automaticFetchOnAmplitudeIdentityChange) {
                this.identityStore.addIdentityListener(() => {
                    client === null || client === void 0 ? void 0 : client.fetch();
                });
            }
            return this.waitForConnectorIdentity(this.timeoutMillis);
        });
    }
    getUser() {
        const identity = this.identityStore.getIdentity();
        return {
            user_id: identity.userId,
            device_id: identity.deviceId,
            user_properties: identity.userProperties,
            version: this.contextProvider.versionName,
        };
    }
    track(event) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        if (!this.eventBridge.receiver) {
            return false;
        }
        this.eventBridge.logEvent({
            eventType: event.eventType,
            eventProperties: event.eventProperties,
        });
        return true;
    }
    loadPersistedState() {
        // Avoid reading state if the api key is undefined or an experiment
        // deployment.
        if (!this.apiKey || this.apiKey.startsWith('client-')) {
            return false;
        }
        // New cookie format
        let user = parseAmplitudeCookie(this.apiKey, true);
        if (user) {
            this.commitIdentityToConnector(user);
            return true;
        }
        // Old cookie format
        user = parseAmplitudeCookie(this.apiKey, false);
        if (user) {
            this.commitIdentityToConnector(user);
            return true;
        }
        // Local storage
        user = parseAmplitudeLocalStorage(this.apiKey);
        if (user) {
            this.commitIdentityToConnector(user);
            return true;
        }
        // Session storage
        user = parseAmplitudeSessionStorage(this.apiKey);
        if (user) {
            this.commitIdentityToConnector(user);
            return true;
        }
        return false;
    }
    commitIdentityToConnector(user) {
        const editor = this.identityStore.editIdentity();
        editor.setDeviceId(user.deviceId);
        if (user.userId) {
            editor.setUserId(user.userId);
        }
        editor.commit();
    }
    waitForConnectorIdentity(ms) {
        return __awaiter(this, void 0, void 0, function* () {
            const identity = this.identityStore.getIdentity();
            if (!identity.userId && !identity.deviceId) {
                return Promise.race([
                    new Promise((resolve) => {
                        const listener = () => {
                            resolve();
                            this.identityStore.removeIdentityListener(listener);
                        };
                        this.identityStore.addIdentityListener(listener);
                    }),
                    new Promise((_, reject) => {
                        safeGlobal.setTimeout(reject, ms, 'Timed out waiting for Amplitude Analytics SDK to initialize.');
                    }),
                ]);
            }
        });
    }
}

function unfetch(e,n){return n=n||{},new Promise(function(t,r){var s=new XMLHttpRequest,o=[],u=[],i={},a=function(){return {ok:2==(s.status/100|0),statusText:s.statusText,status:s.status,url:s.responseURL,text:function(){return Promise.resolve(s.responseText)},json:function(){return Promise.resolve(JSON.parse(s.responseText))},blob:function(){return Promise.resolve(new Blob([s.response]))},clone:a,headers:{keys:function(){return o},entries:function(){return u},get:function(e){return i[e.toLowerCase()]},has:function(e){return e.toLowerCase()in i}}}};for(var l in s.open(n.method||"get",e,!0),s.onload=function(){s.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm,function(e,n,t){o.push(n=n.toLowerCase()),u.push([n,t]),i[n]=i[n]?i[n]+","+t:t;}),t(a());},s.onerror=r,s.withCredentials="include"==n.credentials,n.headers)s.setRequestHeader(l,n.headers[l]);s.send(n.body||null);})}

/**
 * @packageDocumentation
 * @internal
 */
const fetch = safeGlobal.fetch || unfetch;
/*
 * Copied from:
 * https://github.com/github/fetch/issues/175#issuecomment-284787564
 */
const timeout = (promise, timeoutMillis) => {
    // Don't timeout if timeout is null or invalid
    if (timeoutMillis == null || timeoutMillis <= 0) {
        return promise;
    }
    return new Promise(function (resolve, reject) {
        safeGlobal.setTimeout(function () {
            reject(new TimeoutError('Request timeout after ' + timeoutMillis + ' milliseconds'));
        }, timeoutMillis);
        promise.then(resolve, reject);
    });
};
const _request = (requestUrl, method, headers, data, timeoutMillis) => {
    const call = () => __awaiter(void 0, void 0, void 0, function* () {
        const response = yield fetch(requestUrl, {
            method: method,
            headers: headers,
            body: data,
        });
        const simpleResponse = {
            status: response.status,
            body: yield response.text(),
        };
        return simpleResponse;
    });
    return timeout(call(), timeoutMillis);
};
/**
 * Wrap the exposed HttpClient in a CoreClient implementation to work with
 * FlagsApi and EvaluationApi.
 */
class WrapperClient {
    constructor(client) {
        this.client = client;
    }
    request(request) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.request(request.requestUrl, request.method, request.headers, null, request.timeoutMillis);
        });
    }
}
const FetchHttpClient = { request: _request };

/**
 * Determines the primary source of variants before falling back.
 *
 * @category Source
 */
var Source;
(function (Source) {
    /**
     * The default way to source variants within your application. Before the
     * assignments are fetched, `getVariant(s)` will fallback to local storage
     * first, then `initialVariants` if local storage is empty. This option
     * effectively falls back to an assignment fetched previously.
     */
    Source["LocalStorage"] = "localStorage";
    /**
     * This bootstrap option is used primarily for servers-side rendering using an
     * Experiment server SDK. This bootstrap option always prefers the config
     * `initialVariants` over data in local storage, even if variants are fetched
     * successfully and stored locally.
     */
    Source["InitialVariants"] = "initialVariants";
})(Source || (Source = {}));
/**
 * Indicates from which source the variant() function determines the variant
 *
 * @category Source
 */
var VariantSource;
(function (VariantSource) {
    VariantSource["LocalStorage"] = "storage";
    VariantSource["InitialVariants"] = "initial";
    VariantSource["SecondaryLocalStorage"] = "secondary-storage";
    VariantSource["SecondaryInitialVariants"] = "secondary-initial";
    VariantSource["FallbackInline"] = "fallback-inline";
    VariantSource["FallbackConfig"] = "fallback-config";
    VariantSource["LocalEvaluation"] = "local-evaluation";
})(VariantSource || (VariantSource = {}));
/**
 * Returns true if the VariantSource is one of the fallbacks (inline or config)
 *
 * @param source a {@link VariantSource}
 * @returns true if source is {@link VariantSource.FallbackInline} or {@link VariantSource.FallbackConfig}
 */
const isFallback = (source) => {
    return (!source ||
        source === VariantSource.FallbackInline ||
        source === VariantSource.FallbackConfig ||
        source === VariantSource.SecondaryInitialVariants);
};

/**
 Defaults for Experiment Config options

 | **Option**       | **Default**                       |
 |------------------|-----------------------------------|
 | **debug**        | `false`                           |
 | **instanceName** | `$default_instance` |
 | **fallbackVariant**         | `null`                 |
 | **initialVariants**         | `null`                 |
 | **initialFlags**         | `undefined`                 |
 | **source** | `Source.LocalStorage` |
 | **serverUrl**    | `"https://api.lab.amplitude.com"` |
 | **flagsServerUrl**    | `"https://flag.lab.amplitude.com"` |
 | **serverZone**    | `"US"` |
 | **assignmentTimeoutMillis**    | `10000` |
 | **retryFailedAssignment**    | `true` |
 | **automaticExposureTracking** | `true` |
 | **pollOnStart** | `true` |
 | **flagConfigPollingIntervalMillis** | `300000` |
 | **fetchOnStart** | `true` |
 | **automaticFetchOnAmplitudeIdentityChange** | `false` |
 | **userProvider**    | `null` |
 | **analyticsProvider**    | `null` |
 | **exposureTrackingProvider**    | `null` |

 *
 * @category Configuration
 */
const Defaults = {
    debug: false,
    instanceName: '$default_instance',
    fallbackVariant: {},
    initialVariants: {},
    initialFlags: undefined,
    source: Source.LocalStorage,
    serverUrl: 'https://api.lab.amplitude.com',
    flagsServerUrl: 'https://flag.lab.amplitude.com',
    serverZone: 'US',
    fetchTimeoutMillis: 10000,
    retryFetchOnFailure: true,
    throwOnError: false,
    automaticExposureTracking: true,
    pollOnStart: true,
    flagConfigPollingIntervalMillis: 300000,
    fetchOnStart: true,
    automaticFetchOnAmplitudeIdentityChange: false,
    userProvider: null,
    analyticsProvider: null,
    exposureTrackingProvider: null,
    httpClient: FetchHttpClient,
};

var version = "1.16.2";

const MAX_QUEUE_SIZE = 512;
/**
 * Handles integration plugin management, event persistence and deduplication.
 */
class IntegrationManager {
    constructor(config, client) {
        var _a;
        this.isReady = new Promise((resolve) => {
            this.resolve = resolve;
        });
        this.config = config;
        this.client = client;
        const instanceName = (_a = config.instanceName) !== null && _a !== void 0 ? _a : Defaults.instanceName;
        this.queue = new PersistentTrackingQueue(instanceName);
        this.cache = new SessionDedupeCache(instanceName);
    }
    /**
     * Returns a promise when the integration has completed setup. If no
     * integration has been set, returns a resolved promise.
     */
    ready() {
        if (!this.integration) {
            return Promise.resolve();
        }
        return this.isReady;
    }
    /**
     * Set the integration to be managed. An existing integration is torndown,
     * and the new integration is setup. This function resolves the promise
     * returned by ready() if it has not already been resolved.
     *
     * @param integration the integration to manage.
     */
    setIntegration(integration) {
        if (this.integration && this.integration.teardown) {
            void this.integration.teardown();
        }
        this.integration = integration;
        if (integration.setup) {
            this.integration.setup(this.config, this.client).then(() => {
                this.queue.setTracker(this.integration.track.bind(integration));
                this.resolve();
            }, () => {
                this.queue.setTracker(this.integration.track.bind(integration));
                this.resolve();
            });
        }
        else {
            this.queue.setTracker(this.integration.track.bind(integration));
            this.resolve();
        }
    }
    /**
     * Get the user from the integration. If no integration is set, returns an
     * empty object.
     */
    getUser() {
        if (!this.integration) {
            return {};
        }
        return this.integration.getUser();
    }
    /**
     * Deduplicates exposures using session storage, then tracks the event to the
     * integration. If no integration is set, or if the integration returns false,
     * the event is persisted in local storage.
     *
     * @param exposure
     */
    track(exposure) {
        if (this.cache.shouldTrack(exposure)) {
            const event = this.getExposureEvent(exposure);
            this.queue.push(event);
        }
    }
    getExposureEvent(exposure) {
        var _a, _b, _c;
        let event = {
            eventType: '$exposure',
            eventProperties: exposure,
        };
        if ((_a = exposure.metadata) === null || _a === void 0 ? void 0 : _a.exposureEvent) {
            // Metadata specifically passes the exposure event definition
            event = {
                eventType: (_b = exposure.metadata) === null || _b === void 0 ? void 0 : _b.exposureEvent,
                eventProperties: exposure,
            };
        }
        else if (((_c = exposure.metadata) === null || _c === void 0 ? void 0 : _c.deliveryMethod) === 'web') {
            // Web experiments track impression events by default
            event = {
                eventType: '$impression',
                eventProperties: exposure,
            };
        }
        return event;
    }
}
class SessionDedupeCache {
    constructor(instanceName) {
        this.isSessionStorageAvailable = checkIsSessionStorageAvailable();
        this.inMemoryCache = {};
        this.storageKey = `EXP_sent_v2_${instanceName}`;
        // Remove previous version of storage if it exists.
        if (this.isSessionStorageAvailable) {
            safeGlobal.sessionStorage.removeItem(`EXP_sent_${instanceName}`);
        }
    }
    shouldTrack(exposure) {
        var _a;
        // Always track web impressions.
        if (((_a = exposure.metadata) === null || _a === void 0 ? void 0 : _a.deliveryMethod) === 'web') {
            return true;
        }
        this.loadCache();
        const cachedExposure = this.inMemoryCache[exposure.flag_key];
        let shouldTrack = false;
        if (!cachedExposure || cachedExposure.variant !== exposure.variant) {
            shouldTrack = true;
            this.inMemoryCache[exposure.flag_key] = exposure;
        }
        this.storeCache();
        return shouldTrack;
    }
    loadCache() {
        if (this.isSessionStorageAvailable) {
            const storedCache = safeGlobal.sessionStorage.getItem(this.storageKey);
            this.inMemoryCache = storedCache ? JSON.parse(storedCache) : {};
        }
    }
    storeCache() {
        if (this.isSessionStorageAvailable) {
            safeGlobal.sessionStorage.setItem(this.storageKey, JSON.stringify(this.inMemoryCache));
        }
    }
}
class PersistentTrackingQueue {
    constructor(instanceName, maxQueueSize = MAX_QUEUE_SIZE) {
        this.isLocalStorageAvailable = isLocalStorageAvailable();
        this.inMemoryQueue = [];
        this.storageKey = `EXP_unsent_${instanceName}`;
        this.maxQueueSize = maxQueueSize;
    }
    push(event) {
        this.loadQueue();
        this.inMemoryQueue.push(event);
        this.flush();
        this.storeQueue();
    }
    setTracker(tracker) {
        this.tracker = tracker;
        this.poller = safeGlobal.setInterval(() => {
            this.loadFlushStore();
        }, 1000);
        this.loadFlushStore();
    }
    flush() {
        if (!this.tracker)
            return;
        if (this.inMemoryQueue.length === 0)
            return;
        for (const event of this.inMemoryQueue) {
            try {
                if (!this.tracker(event)) {
                    return;
                }
            }
            catch (e) {
                return;
            }
        }
        this.inMemoryQueue = [];
        if (this.poller) {
            safeGlobal.clearInterval(this.poller);
            this.poller = undefined;
        }
    }
    loadQueue() {
        if (this.isLocalStorageAvailable) {
            const storedQueue = safeGlobal.localStorage.getItem(this.storageKey);
            this.inMemoryQueue = storedQueue ? JSON.parse(storedQueue) : [];
        }
    }
    storeQueue() {
        if (this.isLocalStorageAvailable) {
            // Trim the queue if it is too large.
            if (this.inMemoryQueue.length > this.maxQueueSize) {
                this.inMemoryQueue = this.inMemoryQueue.slice(this.inMemoryQueue.length - this.maxQueueSize);
            }
            safeGlobal.localStorage.setItem(this.storageKey, JSON.stringify(this.inMemoryQueue));
        }
    }
    loadFlushStore() {
        this.loadQueue();
        this.flush();
        this.storeQueue();
    }
}
const checkIsSessionStorageAvailable = () => {
    const globalScope = getGlobalScope();
    if (globalScope) {
        try {
            const testKey = 'EXP_test';
            globalScope.sessionStorage.setItem(testKey, testKey);
            globalScope.sessionStorage.removeItem(testKey);
            return true;
        }
        catch (e) {
            return false;
        }
    }
    return false;
};

class LocalStorage {
    constructor() {
        this.globalScope = getGlobalScope();
    }
    get(key) {
        var _a;
        return (_a = this.globalScope) === null || _a === void 0 ? void 0 : _a.localStorage.getItem(key);
    }
    put(key, value) {
        var _a;
        (_a = this.globalScope) === null || _a === void 0 ? void 0 : _a.localStorage.setItem(key, value);
    }
    delete(key) {
        var _a;
        (_a = this.globalScope) === null || _a === void 0 ? void 0 : _a.localStorage.removeItem(key);
    }
}

const getVariantStorage = (deploymentKey, instanceName, storage) => {
    const truncatedDeployment = deploymentKey.substring(deploymentKey.length - 6);
    const namespace = `amp-exp-${instanceName}-${truncatedDeployment}`;
    return new LoadStoreCache(namespace, storage, transformVariantFromStorage);
};
const getFlagStorage = (deploymentKey, instanceName, storage = new LocalStorage()) => {
    const truncatedDeployment = deploymentKey.substring(deploymentKey.length - 6);
    const namespace = `amp-exp-${instanceName}-${truncatedDeployment}-flags`;
    return new LoadStoreCache(namespace, storage);
};
class LoadStoreCache {
    constructor(namespace, storage, transformer) {
        this.cache = {};
        this.namespace = namespace;
        this.storage = storage;
        this.transformer = transformer;
    }
    get(key) {
        return this.cache[key];
    }
    getAll() {
        return Object.assign({}, this.cache);
    }
    put(key, value) {
        this.cache[key] = value;
    }
    putAll(values) {
        for (const key of Object.keys(values)) {
            this.cache[key] = values[key];
        }
    }
    remove(key) {
        delete this.cache[key];
    }
    clear() {
        this.cache = {};
    }
    load() {
        const rawValues = this.storage.get(this.namespace);
        let jsonValues;
        try {
            jsonValues = JSON.parse(rawValues) || {};
        }
        catch (_a) {
            // Do nothing
            return;
        }
        const values = {};
        for (const key of Object.keys(jsonValues)) {
            try {
                let value;
                if (this.transformer) {
                    value = this.transformer(jsonValues[key]);
                }
                else {
                    value = jsonValues[key];
                }
                if (value) {
                    values[key] = value;
                }
            }
            catch (_b) {
                // Do nothing
            }
        }
        this.clear();
        this.putAll(values);
    }
    store(values = this.cache) {
        this.storage.put(this.namespace, JSON.stringify(values));
    }
}
const transformVariantFromStorage = (storageValue) => {
    if (typeof storageValue === 'string') {
        // From v0 string format
        return {
            key: storageValue,
            value: storageValue,
        };
    }
    else if (typeof storageValue === 'object') {
        // From v1 or v2 object format
        const key = storageValue['key'];
        const value = storageValue['value'];
        const payload = storageValue['payload'];
        let metadata = storageValue['metadata'];
        let experimentKey = storageValue['expKey'];
        if (metadata && metadata.experimentKey) {
            experimentKey = metadata.experimentKey;
        }
        else if (experimentKey) {
            metadata = metadata || {};
            metadata['experimentKey'] = experimentKey;
        }
        const variant = {};
        if (key) {
            variant.key = key;
        }
        else if (value) {
            variant.key = value;
        }
        if (value)
            variant.value = value;
        if (metadata)
            variant.metadata = metadata;
        if (payload)
            variant.payload = payload;
        if (experimentKey)
            variant.expKey = experimentKey;
        return variant;
    }
};

class SessionStorage {
    constructor() {
        this.globalScope = getGlobalScope();
    }
    get(key) {
        var _a;
        return (_a = this.globalScope) === null || _a === void 0 ? void 0 : _a.sessionStorage.getItem(key);
    }
    put(key, value) {
        var _a;
        (_a = this.globalScope) === null || _a === void 0 ? void 0 : _a.sessionStorage.setItem(key, value);
    }
    delete(key) {
        var _a;
        (_a = this.globalScope) === null || _a === void 0 ? void 0 : _a.sessionStorage.removeItem(key);
    }
}

/**
 * Event for tracking a user's exposure to a variant. This event will not count
 * towards your analytics event volume.
 *
 * @deprecated use ExposureTrackingProvider instead
 */
const exposureEvent = (user, key, variant, source) => {
    const name = '[Experiment] Exposure';
    const value = variant === null || variant === void 0 ? void 0 : variant.value;
    const userProperty = `[Experiment] ${key}`;
    return {
        name,
        user,
        key,
        variant,
        userProperty,
        properties: {
            key,
            variant: value,
            source,
        },
        userProperties: {
            [userProperty]: value,
        },
    };
};

const isNullOrUndefined = (value) => {
    return value === null || value === undefined;
};
const isNullUndefinedOrEmpty = (value) => {
    if (isNullOrUndefined(value))
        return true;
    return value && Object.keys(value).length === 0;
};
/**
 * Filters out null and undefined values from an object, returning a new object
 * with only defined values. This is useful for config merging where you want
 * defaults to take precedence over explicit null/undefined values.
 */
const filterNullUndefined = (obj) => {
    if (!obj || typeof obj !== 'object') {
        return {};
    }
    const filtered = {};
    for (const [key, value] of Object.entries(obj)) {
        if (!isNullOrUndefined(value)) {
            filtered[key] = value;
        }
    }
    return filtered;
};
const isLocalEvaluationMode = (flag) => {
    var _a;
    return ((_a = flag === null || flag === void 0 ? void 0 : flag.metadata) === null || _a === void 0 ? void 0 : _a.evaluationMode) === 'local';
};

class Backoff {
    constructor(attempts, min, max, scalar) {
        this.started = false;
        this.done = false;
        this.attempts = attempts;
        this.min = min;
        this.max = max;
        this.scalar = scalar;
    }
    start(fn) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.started) {
                this.started = true;
            }
            else {
                throw Error('Backoff already started');
            }
            yield this.backoff(fn, 0, this.min);
        });
    }
    cancel() {
        this.done = true;
        clearTimeout(this.timeoutHandle);
    }
    backoff(fn, attempt, delay) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.done) {
                return;
            }
            this.timeoutHandle = safeGlobal.setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                try {
                    yield fn();
                }
                catch (e) {
                    const nextAttempt = attempt + 1;
                    if (nextAttempt < this.attempts) {
                        const nextDelay = Math.min(delay * this.scalar, this.max);
                        this.backoff(fn, nextAttempt, nextDelay);
                    }
                }
            }), delay);
        });
    }
}

const convertUserToContext = (user) => {
    var _a, _b;
    if (!user) {
        return {};
    }
    const context = { user: user };
    // add page context
    const globalScope = getGlobalScope();
    if (globalScope) {
        context.page = {
            url: globalScope.location.href,
        };
    }
    const groups = {};
    if (!user.groups) {
        return context;
    }
    for (const groupType of Object.keys(user.groups)) {
        const groupNames = user.groups[groupType];
        if (groupNames.length > 0 && groupNames[0]) {
            const groupName = groupNames[0];
            const groupNameMap = {
                group_name: groupName,
            };
            // Check for group properties
            const groupProperties = (_b = (_a = user.group_properties) === null || _a === void 0 ? void 0 : _a[groupType]) === null || _b === void 0 ? void 0 : _b[groupName];
            if (groupProperties && Object.keys(groupProperties).length > 0) {
                groupNameMap['group_properties'] = groupProperties;
            }
            groups[groupType] = groupNameMap;
        }
    }
    if (Object.keys(groups).length > 0) {
        context['groups'] = groups;
    }
    delete context.user['groups'];
    delete context.user['group_properties'];
    return context;
};
const convertVariant = (value) => {
    if (value === null || value === undefined) {
        return {};
    }
    if (typeof value == 'string') {
        return {
            key: value,
            value: value,
        };
    }
    else {
        return value;
    }
};
const convertEvaluationVariantToVariant = (evaluationVariant) => {
    if (!evaluationVariant) {
        return {};
    }
    let experimentKey = undefined;
    if (evaluationVariant.metadata) {
        experimentKey = evaluationVariant.metadata['experimentKey'];
    }
    const variant = {};
    if (evaluationVariant.key)
        variant.key = evaluationVariant.key;
    if (evaluationVariant.value)
        variant.value = evaluationVariant.value;
    if (evaluationVariant.payload)
        variant.payload = evaluationVariant.payload;
    if (experimentKey)
        variant.expKey = experimentKey;
    if (evaluationVariant.metadata)
        variant.metadata = evaluationVariant.metadata;
    return variant;
};

/**
 * A wrapper for an analytics provider which only sends one exposure event per
 * flag, per variant, per session. In other words, wrapping an analytics
 * provider in this class will prevent the same exposure event to be sent twice
 * in one session.
 */
class SessionAnalyticsProvider {
    constructor(analyticsProvider) {
        // In memory record of flagKey and variant value to in order to only set
        // user properties and track an exposure event once per session unless the
        // variant value changes
        this.setProperties = {};
        this.unsetProperties = {};
        this.analyticsProvider = analyticsProvider;
    }
    track(event) {
        if (this.setProperties[event.key] == event.variant.value) {
            return;
        }
        else {
            this.setProperties[event.key] = event.variant.value;
            delete this.unsetProperties[event.key];
        }
        this.analyticsProvider.track(event);
    }
    setUserProperty(event) {
        if (this.setProperties[event.key] == event.variant.value) {
            return;
        }
        this.analyticsProvider.setUserProperty(event);
    }
    unsetUserProperty(event) {
        if (this.unsetProperties[event.key]) {
            return;
        }
        else {
            this.unsetProperties[event.key] = 'unset';
            delete this.setProperties[event.key];
        }
        this.analyticsProvider.unsetUserProperty(event);
    }
}

class SessionExposureTrackingProvider {
    constructor(exposureTrackingProvider) {
        this.tracked = {};
        this.exposureTrackingProvider = exposureTrackingProvider;
    }
    track(exposure) {
        const trackedExposure = this.tracked[exposure.flag_key];
        if (trackedExposure && trackedExposure.variant === exposure.variant) {
            return;
        }
        else {
            this.tracked[exposure.flag_key] = exposure;
            this.exposureTrackingProvider.track(exposure);
        }
    }
}

/**
 * @packageDocumentation
 * @module experiment-js-client
 */
// Configs which have been removed from the public API.
// May be added back in the future.
const fetchBackoffTimeout = 10000;
const fetchBackoffAttempts = 8;
const fetchBackoffMinMillis = 500;
const fetchBackoffMaxMillis = 10000;
const fetchBackoffScalar = 1.5;
const minFlagPollerIntervalMillis = 60000;
const euServerUrl = 'https://api.lab.eu.amplitude.com';
const euFlagsServerUrl = 'https://flag.lab.eu.amplitude.com';
/**
 * The default {@link Client} used to fetch variations from Experiment's
 * servers.
 *
 * @category Core Usage
 */
class ExperimentClient {
    /**
     * Creates a new ExperimentClient instance.
     *
     * In most cases you will want to use the `initialize` factory method in
     * {@link Experiment}.
     *
     * @param apiKey The Client key for the Experiment project
     * @param config See {@link ExperimentConfig} for config options
     */
    constructor(apiKey, config) {
        var _a, _b, _c, _d;
        this.engine = new EvaluationEngine();
        this.isRunning = false;
        this.apiKey = apiKey;
        // Filter out null/undefined values from config to ensure defaults take precedence
        config = filterNullUndefined(config);
        // Merge configs with defaults and wrap providers
        this.config = Object.assign(Object.assign(Object.assign({}, Defaults), config), { 
            // Set server URLs separately
            serverUrl: (config === null || config === void 0 ? void 0 : config.serverUrl) ||
                (((_a = config === null || config === void 0 ? void 0 : config.serverZone) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'eu'
                    ? euServerUrl
                    : Defaults.serverUrl), flagsServerUrl: (config === null || config === void 0 ? void 0 : config.flagsServerUrl) ||
                (((_b = config === null || config === void 0 ? void 0 : config.serverZone) === null || _b === void 0 ? void 0 : _b.toLowerCase()) === 'eu'
                    ? euFlagsServerUrl
                    : Defaults.flagsServerUrl), 
            // Force minimum flag config polling interval.
            flagConfigPollingIntervalMillis: config.flagConfigPollingIntervalMillis < minFlagPollerIntervalMillis
                ? minFlagPollerIntervalMillis
                : (_c = config.flagConfigPollingIntervalMillis) !== null && _c !== void 0 ? _c : Defaults.flagConfigPollingIntervalMillis });
        const internalInstanceName = (_d = this.config) === null || _d === void 0 ? void 0 : _d['internalInstanceNameSuffix'];
        this.isWebExperiment = internalInstanceName === 'web';
        this.poller = new Poller(() => this.doFlags(), this.config.flagConfigPollingIntervalMillis);
        // Transform initialVariants
        if (this.config.initialVariants) {
            for (const flagKey in this.config.initialVariants) {
                this.config.initialVariants[flagKey] = transformVariantFromStorage(this.config.initialVariants[flagKey]);
            }
        }
        if (this.config.userProvider) {
            this.userProvider = this.config.userProvider;
        }
        if (this.config.analyticsProvider) {
            this.analyticsProvider = new SessionAnalyticsProvider(this.config.analyticsProvider);
        }
        if (this.config.exposureTrackingProvider) {
            this.exposureTrackingProvider = new SessionExposureTrackingProvider(this.config.exposureTrackingProvider);
        }
        this.integrationManager = new IntegrationManager(this.config, this);
        // Setup Remote APIs
        const httpClient = new WrapperClient(this.config.httpClient || FetchHttpClient);
        this.flagApi = new SdkFlagApi(this.apiKey, this.config.flagsServerUrl, httpClient);
        this.evaluationApi = new SdkEvaluationApi(this.apiKey, this.config.serverUrl, httpClient);
        // Storage & Caching
        let storage;
        const storageInstanceName = internalInstanceName
            ? `${this.config.instanceName}-${internalInstanceName}`
            : this.config.instanceName;
        if (this.isWebExperiment) {
            storage = new SessionStorage();
        }
        else {
            storage = new LocalStorage();
        }
        this.variants = getVariantStorage(this.apiKey, storageInstanceName, storage);
        this.flags = getFlagStorage(this.apiKey, storageInstanceName, storage);
        try {
            this.flags.load();
            this.variants.load();
        }
        catch (e) {
            // catch localStorage undefined error
        }
        this.mergeInitialFlagsWithStorage();
    }
    /**
     * Start the SDK by getting flag configurations from the server and fetching
     * variants for the user. The promise returned by this function resolves when
     * local flag configurations have been updated, and the {@link fetch()}
     * result has been received (if the request was made).
     *
     * To force this function not to fetch variants, set the {@link fetchOnStart}
     * configuration option to `false` when initializing the SDK.
     *
     * Finally, this function will start polling for flag configurations at a
     * fixed interval. To disable polling, set the {@link pollOnStart}
     * configuration option to `false` on initialization.
     *
     * @param user The user to set in the SDK.
     * @see fetchOnStart
     * @see pollOnStart
     * @see fetch
     * @see variant
     */
    start(user) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (this.isRunning) {
                return;
            }
            else {
                this.isRunning = true;
            }
            this.setUser(user);
            try {
                const flagsReadyPromise = this.doFlags();
                const fetchOnStart = (_a = this.config.fetchOnStart) !== null && _a !== void 0 ? _a : true;
                if (fetchOnStart) {
                    yield Promise.all([this.fetch(user), flagsReadyPromise]);
                }
                else {
                    yield flagsReadyPromise;
                }
            }
            catch (e) {
                // If throwOnError is true, rethrow the error
                if (this.config.throwOnError) {
                    throw e;
                }
                // Otherwise, silently handle the error (existing behavior)
            }
            if (this.config.pollOnStart) {
                this.poller.start();
            }
        });
    }
    /**
     * Stop the local flag configuration poller.
     */
    stop() {
        if (!this.isRunning) {
            return;
        }
        this.poller.stop();
        this.isRunning = false;
    }
    /**
     * Assign the given user to the SDK and asynchronously fetch all variants
     * from the server. Subsequent calls may omit the user from the argument to
     * use the user from the previous call.
     *
     * If an {@link ExperimentUserProvider} has been set, the argument user will
     * be merged with the provider user, preferring user fields from the argument
     * user and falling back on the provider for fields which are null or
     * undefined.
     *
     * If configured, fetch retries the request in the background on failure.
     * Variants received from a successful retry are stored in local storage for
     * access.
     *
     * If you are using the `initialVariants` config option to preload this SDK
     * from the server, you generally do not need to call `fetch`.
     *
     * @param user The user to fetch variants for.
     * @param options Options for this specific fetch call.
     * @returns Promise that resolves when the request for variants completes.
     * @see ExperimentUser
     * @see ExperimentUserProvider
     * @see FetchOptions
     */
    fetch() {
        return __awaiter(this, arguments, void 0, function* (user = this.user, options) {
            this.setUser(user || {});
            try {
                yield this.fetchInternal(user, this.config.fetchTimeoutMillis, this.config.retryFetchOnFailure, options);
            }
            catch (e) {
                // If throwOnError is configured to true, rethrow the error
                if (this.config.throwOnError) {
                    throw e;
                }
                // Otherwise, handle errors silently as before
                if (this.config.debug) {
                    if (e instanceof TimeoutError) {
                        console.debug(e);
                    }
                    else {
                        console.error(e);
                    }
                }
            }
            return this;
        });
    }
    /**
     * Returns the variant for the provided key.
     *
     * Access the variant from {@link Source}, falling back  on the given
     * fallback, then the configured fallbackVariant.
     *
     * If an {@link ExposureTrackingProvider} is configured and the
     * {@link automaticExposureTracking} configuration option is `true`, this
     * function will call the provider with an {@link Exposure} event. The
     * exposure event does not count towards your event volume within Amplitude.
     *
     * @param key The key to get the variant for.
     * @param fallback The highest priority fallback.
     * @see ExperimentConfig
     * @see ExposureTrackingProvider
     */
    variant(key, fallback) {
        var _a, _b;
        if (!this.apiKey) {
            return { value: undefined };
        }
        const sourceVariant = this.variantAndSource(key, fallback);
        if (this.config.automaticExposureTracking) {
            this.exposureInternal(key, sourceVariant);
        }
        this.debug(`[Experiment] variant for ${key} is ${((_a = sourceVariant.variant) === null || _a === void 0 ? void 0 : _a.key) || ((_b = sourceVariant.variant) === null || _b === void 0 ? void 0 : _b.value)}`);
        return sourceVariant.variant || {};
    }
    /**
     * Track an exposure event for the variant associated with the flag/experiment
     * {@link key}.
     *
     * This method requires that an {@link ExposureTrackingProvider} be
     * configured when this client is initialized, either manually, or through the
     * Amplitude Analytics SDK integration from set up using
     * {@link Experiment.initializeWithAmplitudeAnalytics}.
     *
     * @param key The flag/experiment key to track an exposure for.
     * @see ExposureTrackingProvider
     */
    exposure(key) {
        const sourceVariant = this.variantAndSource(key);
        this.exposureInternal(key, sourceVariant);
    }
    /**
     * Returns all variants for the user.
     *
     * The primary source of variants is based on the
     * {@link Source} configured in the {@link ExperimentConfig}.
     *
     * @see Source
     * @see ExperimentConfig
     */
    all() {
        if (!this.apiKey) {
            return {};
        }
        const evaluatedVariants = this.evaluate();
        for (const flagKey in evaluatedVariants) {
            const flag = this.flags.get(flagKey);
            if (!isLocalEvaluationMode(flag)) {
                delete evaluatedVariants[flagKey];
            }
        }
        return Object.assign(Object.assign(Object.assign({}, this.secondaryVariants()), this.sourceVariants()), evaluatedVariants);
    }
    /**
     * Clear all variants in the cache and storage.
     */
    clear() {
        this.variants.clear();
        try {
            void this.variants.store();
        }
        catch (e) {
            // catch localStorage undefined error
        }
    }
    /**
     * Get a copy of the internal {@link ExperimentUser} object if it is set.
     *
     * @returns a copy of the internal user object if set.
     */
    getUser() {
        var _a;
        if (!this.user) {
            return this.user;
        }
        if ((_a = this.user) === null || _a === void 0 ? void 0 : _a.user_properties) {
            const userPropertiesCopy = Object.assign({}, this.user.user_properties);
            return Object.assign(Object.assign({}, this.user), { user_properties: userPropertiesCopy });
        }
        else {
            return Object.assign({}, this.user);
        }
    }
    /**
     * Copy in and set the user within the experiment client.
     *
     * @param user the user to set within the experiment client.
     */
    setUser(user) {
        var _a;
        if (!user) {
            this.user = null;
            return;
        }
        if ((_a = this.user) === null || _a === void 0 ? void 0 : _a.user_properties) {
            const userPropertiesCopy = Object.assign({}, user.user_properties);
            this.user = Object.assign(Object.assign({}, user), { user_properties: userPropertiesCopy });
        }
        else {
            this.user = Object.assign({}, user);
        }
    }
    /**
     * Get the user provider set by {@link setUserProvider} or null if the user
     * provider has not been set.
     *
     * @returns The user provider set by {@link setUserProvider} or null.
     * @deprecated use ExperimentConfig.userProvider instead
     */
    getUserProvider() {
        return this.userProvider;
    }
    /**
     * Sets a user provider that will inject identity information into the user
     * for {@link fetch()} requests. The user provider will only set user fields
     * in outgoing requests which are null or undefined.
     *
     * See {@link ExperimentUserProvider} for more details
     * @param userProvider
     * @deprecated use ExperimentConfig.userProvider instead
     */
    setUserProvider(userProvider) {
        this.userProvider = userProvider;
        return this;
    }
    mergeInitialFlagsWithStorage() {
        if (this.config.initialFlags) {
            const initialFlags = JSON.parse(this.config.initialFlags);
            initialFlags.forEach((flag) => {
                if (!this.flags.get(flag.key)) {
                    this.flags.put(flag.key, flag);
                }
            });
        }
    }
    evaluate(flagKeys) {
        const user = this.addContext(this.user);
        const flags = topologicalSort(this.flags.getAll(), flagKeys);
        const context = convertUserToContext(user);
        const evaluationVariants = this.engine.evaluate(context, flags);
        const variants = {};
        for (const flagKey of Object.keys(evaluationVariants)) {
            variants[flagKey] = convertEvaluationVariantToVariant(evaluationVariants[flagKey]);
        }
        return variants;
    }
    variantAndSource(key, fallback) {
        let sourceVariant = {};
        if (this.config.source === Source.LocalStorage) {
            sourceVariant = this.localStorageVariantAndSource(key, fallback);
        }
        else if (this.config.source === Source.InitialVariants) {
            sourceVariant = this.initialVariantsVariantAndSource(key, fallback);
        }
        const flag = this.flags.get(key);
        if (isLocalEvaluationMode(flag) || (!sourceVariant.variant && flag)) {
            sourceVariant = this.localEvaluationVariantAndSource(key, flag, fallback);
        }
        return sourceVariant;
    }
    /**
     * This function assumes the flag exists and is local evaluation mode. For
     * local evaluation, fallback order goes:
     *
     *  1. Local evaluation
     *  2. Inline function fallback
     *  3. Initial variants
     *  4. Config fallback
     *
     * If there is a default variant and no fallback, return the default variant.
     */
    localEvaluationVariantAndSource(key, flag, fallback) {
        var _a;
        let defaultSourceVariant = {};
        // Local evaluation
        const variant = this.evaluate([flag.key])[key];
        const source = VariantSource.LocalEvaluation;
        const isLocalEvaluationDefault = (_a = variant === null || variant === void 0 ? void 0 : variant.metadata) === null || _a === void 0 ? void 0 : _a.default;
        if (!isNullOrUndefined(variant) && !isLocalEvaluationDefault) {
            return {
                variant: convertVariant(variant),
                source: source,
                hasDefaultVariant: false,
            };
        }
        else if (isLocalEvaluationDefault) {
            defaultSourceVariant = {
                variant: convertVariant(variant),
                source: source,
                hasDefaultVariant: true,
            };
        }
        // Inline fallback
        if (!isNullOrUndefined(fallback)) {
            return {
                variant: convertVariant(fallback),
                source: VariantSource.FallbackInline,
                hasDefaultVariant: defaultSourceVariant.hasDefaultVariant,
            };
        }
        // Initial variants
        const initialVariant = this.config.initialVariants[key];
        if (!isNullOrUndefined(initialVariant)) {
            return {
                variant: convertVariant(initialVariant),
                source: VariantSource.SecondaryInitialVariants,
                hasDefaultVariant: defaultSourceVariant.hasDefaultVariant,
            };
        }
        // Configured fallback, or default variant
        const fallbackVariant = convertVariant(this.config.fallbackVariant);
        const fallbackSourceVariant = {
            variant: fallbackVariant,
            source: VariantSource.FallbackConfig,
            hasDefaultVariant: defaultSourceVariant.hasDefaultVariant,
        };
        if (!isNullUndefinedOrEmpty(fallbackVariant)) {
            return fallbackSourceVariant;
        }
        return defaultSourceVariant;
    }
    /**
     * For Source.LocalStorage, fallback order goes:
     *
     *  1. Local Storage
     *  2. Inline function fallback
     *  3. InitialFlags
     *  4. Config fallback
     *
     * If there is a default variant and no fallback, return the default variant.
     */
    localStorageVariantAndSource(key, fallback) {
        var _a;
        let defaultSourceVariant = {};
        // Local storage
        const localStorageVariant = this.variants.get(key);
        const isLocalStorageDefault = (_a = localStorageVariant === null || localStorageVariant === void 0 ? void 0 : localStorageVariant.metadata) === null || _a === void 0 ? void 0 : _a.default;
        if (!isNullOrUndefined(localStorageVariant) && !isLocalStorageDefault) {
            return {
                variant: convertVariant(localStorageVariant),
                source: VariantSource.LocalStorage,
                hasDefaultVariant: false,
            };
        }
        else if (isLocalStorageDefault) {
            defaultSourceVariant = {
                variant: convertVariant(localStorageVariant),
                source: VariantSource.LocalStorage,
                hasDefaultVariant: true,
            };
        }
        // Inline fallback
        if (!isNullOrUndefined(fallback)) {
            return {
                variant: convertVariant(fallback),
                source: VariantSource.FallbackInline,
                hasDefaultVariant: defaultSourceVariant.hasDefaultVariant,
            };
        }
        // Initial variants
        const initialVariant = this.config.initialVariants[key];
        if (!isNullOrUndefined(initialVariant)) {
            return {
                variant: convertVariant(initialVariant),
                source: VariantSource.SecondaryInitialVariants,
                hasDefaultVariant: defaultSourceVariant.hasDefaultVariant,
            };
        }
        // Configured fallback, or default variant
        const fallbackVariant = convertVariant(this.config.fallbackVariant);
        const fallbackSourceVariant = {
            variant: fallbackVariant,
            source: VariantSource.FallbackConfig,
            hasDefaultVariant: defaultSourceVariant.hasDefaultVariant,
        };
        if (!isNullUndefinedOrEmpty(fallbackVariant)) {
            return fallbackSourceVariant;
        }
        return defaultSourceVariant;
    }
    /**
     * For Source.InitialVariants, fallback order goes:
     *
     *  1. Initial variants
     *  2. Local storage
     *  3. Inline function fallback
     *  4. Config fallback
     *
     * If there is a default variant and no fallback, return the default variant.
     */
    initialVariantsVariantAndSource(key, fallback) {
        var _a;
        let defaultSourceVariant = {};
        // Initial variants
        const initialVariantsVariant = this.config.initialVariants[key];
        if (!isNullOrUndefined(initialVariantsVariant)) {
            return {
                variant: convertVariant(initialVariantsVariant),
                source: VariantSource.InitialVariants,
                hasDefaultVariant: false,
            };
        }
        // Local storage
        const localStorageVariant = this.variants.get(key);
        const isLocalStorageDefault = (_a = localStorageVariant === null || localStorageVariant === void 0 ? void 0 : localStorageVariant.metadata) === null || _a === void 0 ? void 0 : _a.default;
        if (!isNullOrUndefined(localStorageVariant) && !isLocalStorageDefault) {
            return {
                variant: convertVariant(localStorageVariant),
                source: VariantSource.LocalStorage,
                hasDefaultVariant: false,
            };
        }
        else if (isLocalStorageDefault) {
            defaultSourceVariant = {
                variant: convertVariant(localStorageVariant),
                source: VariantSource.LocalStorage,
                hasDefaultVariant: true,
            };
        }
        // Inline fallback
        if (!isNullOrUndefined(fallback)) {
            return {
                variant: convertVariant(fallback),
                source: VariantSource.FallbackInline,
                hasDefaultVariant: defaultSourceVariant.hasDefaultVariant,
            };
        }
        // Configured fallback, or default variant
        const fallbackVariant = convertVariant(this.config.fallbackVariant);
        const fallbackSourceVariant = {
            variant: fallbackVariant,
            source: VariantSource.FallbackConfig,
            hasDefaultVariant: defaultSourceVariant.hasDefaultVariant,
        };
        if (!isNullUndefinedOrEmpty(fallbackVariant)) {
            return fallbackSourceVariant;
        }
        return defaultSourceVariant;
    }
    fetchInternal(user, timeoutMillis, retry, options) {
        return __awaiter(this, void 0, void 0, function* () {
            // Don't even try to fetch variants if API key is not set
            if (!this.apiKey) {
                throw Error('Experiment API key is empty');
            }
            this.debug(`[Experiment] Fetch all: retry=${retry}`);
            // Proactively cancel retries if active in order to avoid unnecessary API
            // requests. A new failure will restart the retries.
            if (retry) {
                this.stopRetries();
            }
            try {
                const variants = yield this.doFetch(user, timeoutMillis, options);
                yield this.storeVariants(variants, options);
                return variants;
            }
            catch (e) {
                if (retry && this.shouldRetryFetch(e)) {
                    void this.startRetries(user, options);
                }
                throw e;
            }
        });
    }
    cleanUserPropsForFetch(user) {
        const cleanedUser = Object.assign({}, user);
        delete cleanedUser.cookie;
        return cleanedUser;
    }
    doFetch(user, timeoutMillis, options) {
        return __awaiter(this, void 0, void 0, function* () {
            user = yield this.addContextOrWait(user);
            user = this.cleanUserPropsForFetch(user);
            this.debug('[Experiment] Fetch variants for user: ', user);
            const results = yield this.evaluationApi.getVariants(user, Object.assign({ timeoutMillis: timeoutMillis }, options));
            const variants = {};
            for (const key of Object.keys(results)) {
                variants[key] = convertEvaluationVariantToVariant(results[key]);
            }
            this.debug('[Experiment] Received variants: ', variants);
            return variants;
        });
    }
    doFlags() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let user;
                if (this.isWebExperiment) {
                    user = yield this.addContextOrWait(this.getUser());
                }
                const flags = yield this.flagApi.getFlags({
                    libraryName: 'experiment-js-client',
                    libraryVersion: version,
                    timeoutMillis: this.config.fetchTimeoutMillis,
                    deliveryMethod: this.isWebExperiment ? 'web' : undefined,
                    user: (user === null || user === void 0 ? void 0 : user.user_id) || (user === null || user === void 0 ? void 0 : user.device_id)
                        ? { user_id: user === null || user === void 0 ? void 0 : user.user_id, device_id: user === null || user === void 0 ? void 0 : user.device_id }
                        : undefined,
                });
                this.flags.clear();
                this.flags.putAll(flags);
            }
            catch (e) {
                if (e instanceof TimeoutError) {
                    this.config.debug && console.debug(e);
                    // If throwOnError is configured to true, rethrow timeout errors
                    if (this.config.throwOnError) {
                        throw e;
                    }
                }
                else {
                    throw e;
                }
            }
            try {
                this.flags.store();
            }
            catch (e) {
                // catch localStorage undefined error
            }
            this.mergeInitialFlagsWithStorage();
        });
    }
    storeVariants(variants, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let failedFlagKeys = options && options.flagKeys ? options.flagKeys : [];
            if (failedFlagKeys.length === 0) {
                this.variants.clear();
            }
            for (const key in variants) {
                failedFlagKeys = failedFlagKeys.filter((flagKey) => flagKey !== key);
                this.variants.put(key, variants[key]);
            }
            for (const key in failedFlagKeys) {
                this.variants.remove(key);
            }
            try {
                this.variants.store();
            }
            catch (e) {
                // catch localStorage undefined error
            }
            this.debug('[Experiment] Stored variants: ', variants);
        });
    }
    startRetries(user, options) {
        return __awaiter(this, void 0, void 0, function* () {
            this.debug('[Experiment] Retry fetch');
            this.retriesBackoff = new Backoff(fetchBackoffAttempts, fetchBackoffMinMillis, fetchBackoffMaxMillis, fetchBackoffScalar);
            void this.retriesBackoff.start(() => __awaiter(this, void 0, void 0, function* () {
                yield this.fetchInternal(user, fetchBackoffTimeout, false, options);
            }));
        });
    }
    stopRetries() {
        if (this.retriesBackoff) {
            this.retriesBackoff.cancel();
        }
    }
    addContext(user) {
        var _a;
        const providedUser = (_a = this.userProvider) === null || _a === void 0 ? void 0 : _a.getUser();
        const integrationUser = this.integrationManager.getUser();
        const mergedUserProperties = Object.assign(Object.assign(Object.assign({}, providedUser === null || providedUser === void 0 ? void 0 : providedUser.user_properties), integrationUser.user_properties), user === null || user === void 0 ? void 0 : user.user_properties);
        return Object.assign(Object.assign(Object.assign(Object.assign({ library: `experiment-js-client/${version}` }, providedUser), integrationUser), user), { user_properties: mergedUserProperties });
    }
    addContextOrWait(user) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.integrationManager.ready();
            return this.addContext(user);
        });
    }
    sourceVariants() {
        if (this.config.source == Source.LocalStorage) {
            return this.variants.getAll();
        }
        else if (this.config.source == Source.InitialVariants) {
            return this.config.initialVariants;
        }
    }
    secondaryVariants() {
        if (this.config.source == Source.LocalStorage) {
            return this.config.initialVariants;
        }
        else if (this.config.source == Source.InitialVariants) {
            return this.variants.getAll();
        }
    }
    exposureInternal(key, sourceVariant) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        // Variant metadata may disable exposure tracking remotely.
        const trackExposure = (_c = (_b = (_a = sourceVariant.variant) === null || _a === void 0 ? void 0 : _a.metadata) === null || _b === void 0 ? void 0 : _b.trackExposure) !== null && _c !== void 0 ? _c : true;
        if (!trackExposure) {
            return;
        }
        this.legacyExposureInternal(key, sourceVariant.variant, sourceVariant.source);
        const exposure = { flag_key: key };
        // Do not track exposure for fallback variants that are not associated with
        // a default variant.
        const fallback = isFallback(sourceVariant.source);
        if (fallback && !sourceVariant.hasDefaultVariant) {
            return;
        }
        if ((_d = sourceVariant.variant) === null || _d === void 0 ? void 0 : _d.expKey) {
            exposure.experiment_key = (_e = sourceVariant.variant) === null || _e === void 0 ? void 0 : _e.expKey;
        }
        const metadata = (_f = sourceVariant.variant) === null || _f === void 0 ? void 0 : _f.metadata;
        if (!fallback && !(metadata === null || metadata === void 0 ? void 0 : metadata.default)) {
            if ((_g = sourceVariant.variant) === null || _g === void 0 ? void 0 : _g.key) {
                exposure.variant = sourceVariant.variant.key;
            }
            else if ((_h = sourceVariant.variant) === null || _h === void 0 ? void 0 : _h.value) {
                exposure.variant = sourceVariant.variant.value;
            }
        }
        if (metadata)
            exposure.metadata = metadata;
        // Add current URL for web experiments
        if (this.isWebExperiment) {
            const globalScope = getGlobalScope();
            if (globalScope === null || globalScope === void 0 ? void 0 : globalScope.location) {
                try {
                    const url = globalScope.location.href;
                    // Add URL without query parameters
                    exposure.metadata.url = url.split('?')[0] || '';
                }
                catch (e) {
                    // If there's any error getting the URL, continue without it
                }
            }
        }
        (_j = this.exposureTrackingProvider) === null || _j === void 0 ? void 0 : _j.track(exposure);
        this.integrationManager.track(exposure);
    }
    legacyExposureInternal(key, variant, source) {
        var _a, _b, _c, _d, _e;
        if (this.analyticsProvider) {
            const user = this.addContext(this.getUser());
            const event = exposureEvent(user, key, variant, source);
            if (isFallback(source) || !(variant === null || variant === void 0 ? void 0 : variant.value)) {
                (_b = (_a = this.analyticsProvider) === null || _a === void 0 ? void 0 : _a.unsetUserProperty) === null || _b === void 0 ? void 0 : _b.call(_a, event);
            }
            else if (variant === null || variant === void 0 ? void 0 : variant.value) {
                (_d = (_c = this.analyticsProvider) === null || _c === void 0 ? void 0 : _c.setUserProperty) === null || _d === void 0 ? void 0 : _d.call(_c, event);
                (_e = this.analyticsProvider) === null || _e === void 0 ? void 0 : _e.track(event);
            }
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    debug(message, ...optionalParams) {
        if (this.config.debug) {
            console.debug(message, ...optionalParams);
        }
    }
    shouldRetryFetch(e) {
        if (e instanceof FetchError) {
            return e.statusCode < 400 || e.statusCode >= 500 || e.statusCode === 429;
        }
        return true;
    }
    /**
     * Add a plugin to the experiment client.
     * @param plugin the plugin to add.
     */
    addPlugin(plugin) {
        if (plugin.type === 'integration') {
            this.integrationManager.setIntegration(plugin);
        }
    }
}

class DefaultUserProvider {
    constructor(userProvider, apiKey) {
        var _a, _b, _c;
        this.globalScope = getGlobalScope();
        this.userAgent = typeof ((_a = this.globalScope) === null || _a === void 0 ? void 0 : _a.navigator) !== 'undefined'
            ? (_b = this.globalScope) === null || _b === void 0 ? void 0 : _b.navigator.userAgent
            : undefined;
        this.ua = new UAParser(this.userAgent).getResult();
        this.localStorage = new LocalStorage();
        this.sessionStorage = new SessionStorage();
        this.userProvider = userProvider;
        this.apiKey = apiKey;
        this.storageKey = `EXP_${(_c = this.apiKey) === null || _c === void 0 ? void 0 : _c.slice(0, 10)}_DEFAULT_USER_PROVIDER`;
    }
    getUser() {
        var _a, _b, _c, _d, _e;
        const user = ((_a = this.userProvider) === null || _a === void 0 ? void 0 : _a.getUser()) || {};
        return Object.assign({ language: this.getLanguage(), platform: 'Web', os: this.getOs(this.ua), device_model: this.getDeviceModel(this.ua), device_category: (_c = (_b = this.ua.device) === null || _b === void 0 ? void 0 : _b.type) !== null && _c !== void 0 ? _c : 'desktop', referring_url: (_e = (_d = this.globalScope) === null || _d === void 0 ? void 0 : _d.document) === null || _e === void 0 ? void 0 : _e.referrer.replace(/\/$/, ''), cookie: this.getCookie(), browser: this.getBrowser(this.ua), landing_url: this.getLandingUrl(), first_seen: this.getFirstSeen(), url_param: this.getUrlParam(), user_agent: this.userAgent }, user);
    }
    getLanguage() {
        return ((typeof navigator !== 'undefined' &&
            ((navigator.languages && navigator.languages[0]) ||
                navigator.language)) ||
            '');
    }
    getOs(ua) {
        var _a, _b;
        return [(_a = ua.browser) === null || _a === void 0 ? void 0 : _a.name, (_b = ua.browser) === null || _b === void 0 ? void 0 : _b.major]
            .filter((e) => e !== null && e !== undefined)
            .join(' ');
    }
    getDeviceModel(ua) {
        var _a;
        return (_a = ua.os) === null || _a === void 0 ? void 0 : _a.name;
    }
    getBrowser(ua) {
        var _a;
        let browser = (_a = ua.browser) === null || _a === void 0 ? void 0 : _a.name;
        // Normalize for Chrome, Firefox, Safari, Edge, and Opera.
        if (browser === null || browser === void 0 ? void 0 : browser.includes('Chrom'))
            browser = 'Chrome'; // Chrome, Chrome Mobile, Chromium, etc
        if (browser === null || browser === void 0 ? void 0 : browser.includes('Firefox'))
            browser = 'Firefox'; // Firefox, Firefox Mobile, etc
        if (browser === null || browser === void 0 ? void 0 : browser.includes('Safari'))
            browser = 'Safari'; // Safari, Safari Mobile
        if (browser === null || browser === void 0 ? void 0 : browser.includes('Edge'))
            browser = 'Edge'; // Edge
        if (browser === null || browser === void 0 ? void 0 : browser.includes('Opera'))
            browser = 'Opera'; // Opera, Opera Mobi, etc
        return browser;
    }
    getCookie() {
        var _a, _b, _c, _d, _e;
        if (!((_b = (_a = this.globalScope) === null || _a === void 0 ? void 0 : _a.document) === null || _b === void 0 ? void 0 : _b.cookie)) {
            return undefined;
        }
        return Object.fromEntries((_e = (_d = (_c = this.globalScope) === null || _c === void 0 ? void 0 : _c.document) === null || _d === void 0 ? void 0 : _d.cookie) === null || _e === void 0 ? void 0 : _e.split('; ').map((c) => c.split('=')));
    }
    getLandingUrl() {
        var _a, _b;
        try {
            const sessionUser = JSON.parse(this.sessionStorage.get(this.storageKey) || '{}');
            if (!sessionUser.landing_url) {
                sessionUser.landing_url = (_b = (_a = this.globalScope) === null || _a === void 0 ? void 0 : _a.location) === null || _b === void 0 ? void 0 : _b.href.replace(/\/$/, '');
                this.sessionStorage.put(this.storageKey, JSON.stringify(sessionUser));
            }
            return sessionUser.landing_url;
        }
        catch (_c) {
            return undefined;
        }
    }
    getFirstSeen() {
        try {
            const localUser = JSON.parse(this.localStorage.get(this.storageKey) || '{}');
            if (!localUser.first_seen) {
                localUser.first_seen = (Date.now() / 1000).toString();
                this.localStorage.put(this.storageKey, JSON.stringify(localUser));
            }
            return localUser.first_seen;
        }
        catch (_a) {
            return undefined;
        }
    }
    getUrlParam() {
        var _a;
        if (!this.globalScope) {
            return undefined;
        }
        const params = {};
        try {
            const url = new URL(this.globalScope.location.href);
            for (const [name, value] of url.searchParams) {
                params[name] = [...((_a = params[name]) !== null && _a !== void 0 ? _a : []), ...value.split(',')];
            }
        }
        catch (error) {
            return undefined;
        }
        return Object.entries(params).reduce((acc, [name, value]) => {
            acc[name] = value.length == 1 ? value[0] : value;
            return acc;
        }, {});
    }
}

// Global instances for debugging.
safeGlobal.experimentInstances = {};
const instances = safeGlobal.experimentInstances;
/**
 * Initializes a singleton {@link ExperimentClient} identified by the configured
 * instance name.
 *
 * @param apiKey The deployment API Key
 * @param config See {@link ExperimentConfig} for config options
 */
const initialize = (apiKey, config) => {
    return _initialize(apiKey, config);
};
/**
 * Initialize a singleton {@link ExperimentClient} which automatically
 * integrates with the installed and initialized instance of the amplitude
 * analytics SDK.
 *
 * You must be using amplitude-js SDK version 8.17.0+ for this integration to
 * work.
 *
 * @param apiKey The deployment API Key
 * @param config See {@link ExperimentConfig} for config options
 */
const initializeWithAmplitudeAnalytics = (apiKey, config) => {
    const plugin = () => new AmplitudeIntegrationPlugin(apiKey, AnalyticsConnector.getInstance(getInstanceName(config)), 10000);
    return _initialize(apiKey, config, plugin);
};
const getInstanceName = (config) => {
    return (config === null || config === void 0 ? void 0 : config.instanceName) || Defaults.instanceName;
};
const getInstanceKey = (apiKey, config) => {
    // Store instances by appending the instance name and api key. Allows for
    // initializing multiple default instances for different api keys.
    const instanceName = getInstanceName(config);
    // The internal instance name prefix is used by web experiment to differentiate
    // web and feature experiment sdks which use the same api key.
    const internalInstanceNameSuffix = config === null || config === void 0 ? void 0 : config['internalInstanceNameSuffix'];
    return internalInstanceNameSuffix
        ? `${instanceName}.${apiKey}.${internalInstanceNameSuffix}`
        : `${instanceName}.${apiKey}`;
};
const newExperimentClient = (apiKey, config) => {
    return new ExperimentClient(apiKey, Object.assign(Object.assign({}, config), { userProvider: new DefaultUserProvider(config === null || config === void 0 ? void 0 : config.userProvider, apiKey) }));
};
const _initialize = (apiKey, config, plugin) => {
    const instanceKey = getInstanceKey(apiKey, config);
    let client = instances[instanceKey];
    if (client) {
        return client;
    }
    client = newExperimentClient(apiKey, config);
    if (plugin) {
        client.addPlugin(plugin());
    }
    instances[instanceKey] = client;
    return client;
};
/**
 * Provides factory methods for storing singleton instances of {@link ExperimentClient}
 * @category Core Usage
 */
const Experiment = {
    initialize,
    initializeWithAmplitudeAnalytics,
};

/**
 * A stub {@link Client} implementation that does nothing for all methods
 */
class StubExperimentClient {
    getUser() {
        return {};
    }
    start(user) {
        return __awaiter(this, void 0, void 0, function* () {
            return;
        });
    }
    stop() { }
    setUser(user) { }
    fetch(user, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this;
        });
    }
    getUserProvider() {
        return null;
    }
    setUserProvider(uerProvider) {
        return this;
    }
    variant(key, fallback) {
        return Defaults.fallbackVariant;
    }
    all() {
        return {};
    }
    clear() { }
    exposure(key) { }
}

export { AmplitudeAnalyticsProvider, AmplitudeIntegrationPlugin, AmplitudeUserProvider, Experiment, ExperimentClient, Source, StubExperimentClient, initialize, initializeWithAmplitudeAnalytics };
