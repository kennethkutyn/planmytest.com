import { ExperimentConfig } from '../config';
import { Client } from '../types/client';
import { Exposure } from '../types/exposure';
import { ExperimentEvent, IntegrationPlugin } from '../types/plugin';
import { ExperimentUser } from '../types/user';
/**
 * Handles integration plugin management, event persistence and deduplication.
 */
export declare class IntegrationManager {
    private readonly config;
    private readonly client;
    private integration;
    private readonly queue;
    private readonly cache;
    private resolve;
    private readonly isReady;
    constructor(config: ExperimentConfig, client: Client);
    /**
     * Returns a promise when the integration has completed setup. If no
     * integration has been set, returns a resolved promise.
     */
    ready(): Promise<void>;
    /**
     * Set the integration to be managed. An existing integration is torndown,
     * and the new integration is setup. This function resolves the promise
     * returned by ready() if it has not already been resolved.
     *
     * @param integration the integration to manage.
     */
    setIntegration(integration: IntegrationPlugin): void;
    /**
     * Get the user from the integration. If no integration is set, returns an
     * empty object.
     */
    getUser(): ExperimentUser;
    /**
     * Deduplicates exposures using session storage, then tracks the event to the
     * integration. If no integration is set, or if the integration returns false,
     * the event is persisted in local storage.
     *
     * @param exposure
     */
    track(exposure: Exposure): void;
    private getExposureEvent;
}
export declare class SessionDedupeCache {
    private readonly storageKey;
    private readonly isSessionStorageAvailable;
    private inMemoryCache;
    constructor(instanceName: string);
    shouldTrack(exposure: Exposure): boolean;
    private loadCache;
    private storeCache;
}
export declare class PersistentTrackingQueue {
    private readonly storageKey;
    private readonly maxQueueSize;
    private readonly isLocalStorageAvailable;
    private inMemoryQueue;
    private poller;
    private tracker;
    constructor(instanceName: string, maxQueueSize?: number);
    push(event: ExperimentEvent): void;
    setTracker(tracker: (event: ExperimentEvent) => boolean): void;
    private flush;
    private loadQueue;
    private storeQueue;
    private loadFlushStore;
}
