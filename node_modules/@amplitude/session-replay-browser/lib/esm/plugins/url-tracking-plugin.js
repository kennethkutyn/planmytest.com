import { __assign } from "tslib";
import { getPageUrl } from '../helpers';
import { DEFAULT_URL_CHANGE_POLLING_INTERVAL } from '../constants';
/**
 * Creates a URL tracking plugin for rrweb record function
 *
 * This plugin monitors URL changes in the browser and emits events when the URL changes.
 * It supports three tracking modes:
 * 1. Polling (if explicitly enabled) - periodically checks for URL changes
 * 2. History API + Hash routing (default) - patches pushState/replaceState, listens to popstate and hashchange
 * 3. Hash routing only (fallback) - listens to hashchange events when History API is unavailable
 *
 * The plugin handles edge cases gracefully:
 * - Missing or null location objects
 * - Undefined, null, or empty location.href values
 * - Temporal dead zone issues with variable declarations
 * - Consistent URL normalization across all code paths
 *
 * @param options Configuration options for URL tracking
 * @returns RecordPlugin instance that can be used with rrweb
 */
export function createUrlTrackingPlugin(options) {
    if (options === void 0) { options = {}; }
    return {
        name: 'amplitude/url-tracking@1',
        observer: function (cb, globalScope, pluginOptions) {
            var _a, _b, _c;
            // Merge options with plugin-level options taking precedence over constructor options
            var config = __assign(__assign({}, options), pluginOptions);
            var ugcFilterRules = config.ugcFilterRules || [];
            var enablePolling = (_a = config.enablePolling) !== null && _a !== void 0 ? _a : false;
            var pollingInterval = (_b = config.pollingInterval) !== null && _b !== void 0 ? _b : DEFAULT_URL_CHANGE_POLLING_INTERVAL;
            var captureDocumentTitle = (_c = config.captureDocumentTitle) !== null && _c !== void 0 ? _c : false;
            // Early return if no global scope is available
            if (!globalScope) {
                return function () {
                    // No cleanup needed if no global scope available
                };
            }
            // Track the last URL to prevent duplicate events
            // Initialize to undefined to ensure first call always emits an event
            var lastTrackedUrl = undefined;
            // Helper functions
            /**
             * Gets the current URL with proper normalization
             * Handles edge cases where location.href might be undefined, null, or empty
             * Ensures consistent behavior across all code paths
             * @returns Normalized URL string (empty string if location unavailable)
             */
            var getCurrentUrl = function () {
                if (!globalScope.location)
                    return '';
                return globalScope.location.href || '';
            };
            /**
             * Creates a URL change event with current page information
             * Applies UGC filtering if rules are configured
             * Uses getCurrentUrl() for consistent URL normalization
             * @returns URLChangeEvent with current page state
             */
            var createUrlChangeEvent = function () {
                var innerHeight = globalScope.innerHeight, innerWidth = globalScope.innerWidth, document = globalScope.document;
                var currentUrl = getCurrentUrl();
                var currentTitle = '';
                if (captureDocumentTitle) {
                    currentTitle = (document === null || document === void 0 ? void 0 : document.title) || '';
                }
                // Apply UGC filtering if rules are provided, otherwise use original URL
                var filteredUrl = ugcFilterRules.length > 0 ? getPageUrl(currentUrl, ugcFilterRules) : currentUrl;
                return {
                    href: filteredUrl,
                    title: currentTitle,
                    viewportHeight: innerHeight,
                    viewportWidth: innerWidth,
                    type: 'url-change-event',
                };
            };
            /**
             * Emits a URL change event if the URL has actually changed
             * Always emits on first call (when lastTrackedUrl is undefined)
             * Prevents duplicate events for the same URL on subsequent calls
             * Handles edge cases like undefined/null/empty URLs gracefully
             */
            var emitUrlChange = function () {
                var currentUrl = getCurrentUrl();
                // Always emit on first call, or if URL actually changed
                if (lastTrackedUrl === undefined || currentUrl !== lastTrackedUrl) {
                    lastTrackedUrl = currentUrl;
                    var event_1 = createUrlChangeEvent();
                    cb(event_1);
                }
            };
            /**
             * Creates a patched version of history methods (pushState/replaceState)
             * that calls the original method and then emits a URL change event
             * Ensures URL changes are detected even when history methods are called programmatically
             * @param originalMethod The original history method to patch
             * @returns Patched function that calls original method then emits URL change event
             */
            var createHistoryMethodPatch = function (originalMethod) {
                return function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    // Call the original history method first
                    var result = originalMethod.apply(this, args);
                    // Then emit URL change event
                    emitUrlChange();
                    return result;
                };
            };
            // Hashchange event handler - delegates to emitUrlChange for consistency
            var hashChangeHandler = function () {
                emitUrlChange();
            };
            // 1. if explicitly enable polling → use polling
            if (enablePolling) {
                // Use polling (covers everything)
                var urlChangeInterval_1 = globalScope.setInterval(function () {
                    emitUrlChange();
                }, pollingInterval);
                // Emit initial URL immediately
                emitUrlChange();
                // Return cleanup function to stop polling
                return function () {
                    if (urlChangeInterval_1) {
                        globalScope.clearInterval(urlChangeInterval_1);
                    }
                };
            }
            // 2. if polling not enabled → check history, if exist, use history
            if (globalScope.history) {
                // Use History API + hashchange (covers History API + hash routing)
                // Store original history methods for restoration during cleanup
                var originalPushState_1 = globalScope.history.pushState.bind(globalScope.history);
                var originalReplaceState_1 = globalScope.history.replaceState.bind(globalScope.history);
                /**
                 * Sets up history method patching to intercept pushState and replaceState calls
                 * This ensures URL changes are detected even when history methods are called programmatically
                 */
                var setupHistoryPatching = function () {
                    // Patch pushState to emit URL change events
                    globalScope.history.pushState = createHistoryMethodPatch(originalPushState_1);
                    // Patch replaceState to emit URL change events
                    globalScope.history.replaceState = createHistoryMethodPatch(originalReplaceState_1);
                };
                // Apply history method patches
                setupHistoryPatching();
                // Listen to popstate events for browser back/forward navigation
                globalScope.addEventListener('popstate', emitUrlChange);
                // Listen to hashchange events for hash routing
                globalScope.addEventListener('hashchange', hashChangeHandler);
                // Emit initial URL immediately
                emitUrlChange();
                // Return cleanup function to restore original state
                return function () {
                    // Restore original history methods
                    globalScope.history.pushState = originalPushState_1;
                    globalScope.history.replaceState = originalReplaceState_1;
                    // Remove popstate event listener
                    globalScope.removeEventListener('popstate', emitUrlChange);
                    // Remove hashchange event listener
                    globalScope.removeEventListener('hashchange', hashChangeHandler);
                };
            }
            // 3. if not, then the framework is probably using hash router → do hash
            // Fallback: just hashchange (for pure hash routing)
            globalScope.addEventListener('hashchange', hashChangeHandler);
            emitUrlChange();
            return function () {
                globalScope.removeEventListener('hashchange', hashChangeHandler);
            };
        },
        options: options,
    };
}
/**
 * Default URL tracking plugin instance with default options
 * Can be used directly without custom configuration
 */
export var urlTrackingPlugin = createUrlTrackingPlugin();
//# sourceMappingURL=url-tracking-plugin.js.map