{"version":3,"file":"url-tracking-plugin.js","sourceRoot":"","sources":["../../../src/plugins/url-tracking-plugin.ts"],"names":[],"mappings":"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","sourcesContent":["import { getPageUrl } from '../helpers';\nimport { UGCFilterRule } from '../config/types';\nimport { DEFAULT_URL_CHANGE_POLLING_INTERVAL } from '../constants';\nimport { RecordPlugin } from '@amplitude/rrweb-types';\n\n/**\n * Event emitted when URL changes are detected by the plugin\n * Contains the current page URL, title, and viewport dimensions\n */\nexport interface URLChangeEvent {\n  /** The current page URL (may be filtered if UGC rules are applied) */\n  href: string;\n  /** The current page title */\n  title: string;\n  /** Viewport height in pixels */\n  viewportHeight: number;\n  /** Viewport width in pixels */\n  viewportWidth: number;\n  /** The type of URL change event */\n  type: string;\n}\n\n/**\n * Configuration options for the URL tracking plugin\n */\nexport interface URLTrackingPluginOptions {\n  /** Rules for filtering sensitive URLs (User Generated Content) */\n  ugcFilterRules?: UGCFilterRule[];\n  /** Whether to use polling instead of history API events for URL detection */\n  enablePolling?: boolean;\n  /** Interval in milliseconds for polling URL changes (default: 1000ms) */\n  pollingInterval?: number;\n  /** Whether to capture document title in URL change events (default: false) */\n  captureDocumentTitle?: boolean;\n}\n\n/**\n * Creates a URL tracking plugin for rrweb record function\n *\n * This plugin monitors URL changes in the browser and emits events when the URL changes.\n * It supports three tracking modes:\n * 1. Polling (if explicitly enabled) - periodically checks for URL changes\n * 2. History API + Hash routing (default) - patches pushState/replaceState, listens to popstate and hashchange\n * 3. Hash routing only (fallback) - listens to hashchange events when History API is unavailable\n *\n * The plugin handles edge cases gracefully:\n * - Missing or null location objects\n * - Undefined, null, or empty location.href values\n * - Temporal dead zone issues with variable declarations\n * - Consistent URL normalization across all code paths\n *\n * @param options Configuration options for URL tracking\n * @returns RecordPlugin instance that can be used with rrweb\n */\nexport function createUrlTrackingPlugin(\n  options: URLTrackingPluginOptions = {},\n): RecordPlugin<URLTrackingPluginOptions> {\n  return {\n    name: 'amplitude/url-tracking@1',\n    observer(cb, globalScope, pluginOptions?: URLTrackingPluginOptions) {\n      // Merge options with plugin-level options taking precedence over constructor options\n      const config = { ...options, ...pluginOptions };\n      const ugcFilterRules = config.ugcFilterRules || [];\n      const enablePolling = config.enablePolling ?? false;\n      const pollingInterval = config.pollingInterval ?? DEFAULT_URL_CHANGE_POLLING_INTERVAL;\n      const captureDocumentTitle = config.captureDocumentTitle ?? false;\n\n      // Early return if no global scope is available\n      if (!globalScope) {\n        return () => {\n          // No cleanup needed if no global scope available\n        };\n      }\n\n      // Track the last URL to prevent duplicate events\n      // Initialize to undefined to ensure first call always emits an event\n      let lastTrackedUrl: string | undefined = undefined;\n\n      // Helper functions\n      /**\n       * Gets the current URL with proper normalization\n       * Handles edge cases where location.href might be undefined, null, or empty\n       * Ensures consistent behavior across all code paths\n       * @returns Normalized URL string (empty string if location unavailable)\n       */\n      const getCurrentUrl = (): string => {\n        if (!globalScope.location) return '';\n        return globalScope.location.href || '';\n      };\n\n      /**\n       * Creates a URL change event with current page information\n       * Applies UGC filtering if rules are configured\n       * Uses getCurrentUrl() for consistent URL normalization\n       * @returns URLChangeEvent with current page state\n       */\n      const createUrlChangeEvent = (): URLChangeEvent => {\n        const { innerHeight, innerWidth, document } = globalScope;\n        const currentUrl = getCurrentUrl();\n        let currentTitle = '';\n        if (captureDocumentTitle) {\n          currentTitle = document?.title || '';\n        }\n\n        // Apply UGC filtering if rules are provided, otherwise use original URL\n        const filteredUrl = ugcFilterRules.length > 0 ? getPageUrl(currentUrl, ugcFilterRules) : currentUrl;\n\n        return {\n          href: filteredUrl,\n          title: currentTitle,\n          viewportHeight: innerHeight,\n          viewportWidth: innerWidth,\n          type: 'url-change-event',\n        };\n      };\n\n      /**\n       * Emits a URL change event if the URL has actually changed\n       * Always emits on first call (when lastTrackedUrl is undefined)\n       * Prevents duplicate events for the same URL on subsequent calls\n       * Handles edge cases like undefined/null/empty URLs gracefully\n       */\n      const emitUrlChange = (): void => {\n        const currentUrl = getCurrentUrl();\n\n        // Always emit on first call, or if URL actually changed\n        if (lastTrackedUrl === undefined || currentUrl !== lastTrackedUrl) {\n          lastTrackedUrl = currentUrl;\n          const event = createUrlChangeEvent();\n          cb(event);\n        }\n      };\n\n      /**\n       * Creates a patched version of history methods (pushState/replaceState)\n       * that calls the original method and then emits a URL change event\n       * Ensures URL changes are detected even when history methods are called programmatically\n       * @param originalMethod The original history method to patch\n       * @returns Patched function that calls original method then emits URL change event\n       */\n      const createHistoryMethodPatch = <T extends typeof history.pushState | typeof history.replaceState>(\n        originalMethod: T,\n      ) => {\n        return function (this: History, ...args: Parameters<T>) {\n          // Call the original history method first\n          const result = originalMethod.apply(this, args);\n          // Then emit URL change event\n          emitUrlChange();\n          return result;\n        };\n      };\n\n      // Hashchange event handler - delegates to emitUrlChange for consistency\n      const hashChangeHandler = () => {\n        emitUrlChange();\n      };\n\n      // 1. if explicitly enable polling → use polling\n      if (enablePolling) {\n        // Use polling (covers everything)\n        const urlChangeInterval = globalScope.setInterval(() => {\n          emitUrlChange();\n        }, pollingInterval);\n\n        // Emit initial URL immediately\n        emitUrlChange();\n\n        // Return cleanup function to stop polling\n        return () => {\n          if (urlChangeInterval) {\n            globalScope.clearInterval(urlChangeInterval);\n          }\n        };\n      }\n\n      // 2. if polling not enabled → check history, if exist, use history\n      if (globalScope.history) {\n        // Use History API + hashchange (covers History API + hash routing)\n        // Store original history methods for restoration during cleanup\n        const originalPushState = globalScope.history.pushState.bind(globalScope.history);\n        const originalReplaceState = globalScope.history.replaceState.bind(globalScope.history);\n\n        /**\n         * Sets up history method patching to intercept pushState and replaceState calls\n         * This ensures URL changes are detected even when history methods are called programmatically\n         */\n        const setupHistoryPatching = (): void => {\n          // Patch pushState to emit URL change events\n          globalScope.history.pushState = createHistoryMethodPatch(originalPushState);\n\n          // Patch replaceState to emit URL change events\n          globalScope.history.replaceState = createHistoryMethodPatch(originalReplaceState);\n        };\n\n        // Apply history method patches\n        setupHistoryPatching();\n\n        // Listen to popstate events for browser back/forward navigation\n        globalScope.addEventListener('popstate', emitUrlChange);\n        // Listen to hashchange events for hash routing\n        globalScope.addEventListener('hashchange', hashChangeHandler);\n\n        // Emit initial URL immediately\n        emitUrlChange();\n\n        // Return cleanup function to restore original state\n        return () => {\n          // Restore original history methods\n          globalScope.history.pushState = originalPushState;\n          globalScope.history.replaceState = originalReplaceState;\n\n          // Remove popstate event listener\n          globalScope.removeEventListener('popstate', emitUrlChange);\n          // Remove hashchange event listener\n          globalScope.removeEventListener('hashchange', hashChangeHandler);\n        };\n      }\n\n      // 3. if not, then the framework is probably using hash router → do hash\n      // Fallback: just hashchange (for pure hash routing)\n      globalScope.addEventListener('hashchange', hashChangeHandler);\n      emitUrlChange();\n      return () => {\n        globalScope.removeEventListener('hashchange', hashChangeHandler);\n      };\n    },\n    options,\n  };\n}\n\n/**\n * Default URL tracking plugin instance with default options\n * Can be used directly without custom configuration\n */\nexport const urlTrackingPlugin = createUrlTrackingPlugin();\n"]}