{"version":3,"file":"base-events-store.js","sourceRoot":"","sources":["../../../src/events/base-events-store.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,mBAAmB,EAAE,YAAY,EAAE,YAAY,EAAE,MAAM,cAAc,CAAC;AAW/E;IAYE,yBAAY,IAAkB;QAA9B,iBAKC;;QAfO,gBAAW,GAAG,YAAY,CAAC;QAC3B,gBAAW,GAAG,YAAY,CAAC;QAC3B,2BAAsB,GAAG,mBAAmB,CAAC;QAC7C,aAAQ,GAAG,IAAI,CAAC,WAAW,CAAC;QAC5B,qBAAgB,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC,4EAA4E;QAiDnH;;;;;WAKG;QACH,0BAAqB,GAAG,UAAC,MAAc,EAAE,eAAuB;YAC9D,IAAM,eAAe,GAAG,KAAI,CAAC,aAAa,CAAC,eAAe,CAAC,CAAC;YAC5D,IAAM,gBAAgB,GAAG,KAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,CAAC;YAEzD,uDAAuD;YACvD,IAAI,gBAAgB,GAAG,eAAe,IAAI,KAAI,CAAC,sBAAsB,EAAE;gBACrE,OAAO,IAAI,CAAC;aACb;YACD,IAAI,IAAI,CAAC,GAAG,EAAE,GAAG,KAAI,CAAC,eAAe,GAAG,KAAI,CAAC,QAAQ,IAAI,MAAM,CAAC,MAAM,EAAE;gBACtE,KAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,KAAI,CAAC,WAAW,EAAE,KAAI,CAAC,QAAQ,GAAG,KAAI,CAAC,WAAW,CAAC,CAAC;gBAC7E,KAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;gBACnC,OAAO,IAAI,CAAC;aACb;YACD,OAAO,KAAK,CAAC;QACf,CAAC,CAAC;QA9DA,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,cAAc,CAAC;QAC1C,IAAI,CAAC,WAAW,GAAG,MAAA,IAAI,CAAC,WAAW,mCAAI,IAAI,CAAC,WAAW,CAAC;QACxD,IAAI,CAAC,WAAW,GAAG,MAAA,IAAI,CAAC,WAAW,mCAAI,IAAI,CAAC,WAAW,CAAC;QACxD,IAAI,CAAC,sBAAsB,GAAG,MAAA,IAAI,CAAC,sBAAsB,mCAAI,IAAI,CAAC,sBAAsB,CAAC;IAC3F,CAAC;IATD,sBAAW,4CAAe;aAA1B;YACE,OAAO,IAAI,CAAC,gBAAgB,CAAC;QAC/B,CAAC;;;OAAA;IAkBD;;;OAGG;IACK,uCAAa,GAArB,UAAsB,GAAW;QAC/B,OAAO,GAAG,CAAC,MAAM,CAAC;IACpB,CAAC;IAED;;;OAGG;IACK,4CAAkB,GAA1B,UAA2B,MAAc;;QACvC,IAAI,SAAS,GAAG,CAAC,CAAC;;YAClB,KAAoB,IAAA,WAAA,SAAA,MAAM,CAAA,8BAAA,kDAAE;gBAAvB,IAAM,OAAK,mBAAA;gBACd,SAAS,IAAI,IAAI,CAAC,aAAa,CAAC,OAAK,CAAC,CAAC;aACxC;;;;;;;;;QAED,6DAA6D;QAC7D,sCAAsC;QACtC,6CAA6C;QAC7C,uDAAuD;QACvD,IAAM,QAAQ,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC;QAExE,OAAO,SAAS,GAAG,QAAQ,CAAC;IAC9B,CAAC;IAuBH,sBAAC;AAAD,CAAC,AA5ED,IA4EC","sourcesContent":["import { MAX_EVENT_LIST_SIZE, MAX_INTERVAL, MIN_INTERVAL } from '../constants';\nimport { Events, EventsStore, SendingSequencesReturn } from '../typings/session-replay';\nimport { ILogger } from '@amplitude/analytics-core';\n\nexport type InstanceArgs = {\n  loggerProvider: ILogger;\n  minInterval?: number;\n  maxInterval?: number;\n  maxPersistedEventsSize?: number;\n};\n\nexport abstract class BaseEventsStore<KeyType> implements EventsStore<KeyType> {\n  protected readonly loggerProvider: ILogger;\n  private minInterval = MIN_INTERVAL;\n  private maxInterval = MAX_INTERVAL;\n  private maxPersistedEventsSize = MAX_EVENT_LIST_SIZE;\n  private interval = this.minInterval;\n  private _timeAtLastSplit = Date.now(); // Initialize this so we have a point of comparison when events are recorded\n\n  public get timeAtLastSplit() {\n    return this._timeAtLastSplit;\n  }\n\n  constructor(args: InstanceArgs) {\n    this.loggerProvider = args.loggerProvider;\n    this.minInterval = args.minInterval ?? this.minInterval;\n    this.maxInterval = args.maxInterval ?? this.maxInterval;\n    this.maxPersistedEventsSize = args.maxPersistedEventsSize ?? this.maxPersistedEventsSize;\n  }\n\n  abstract addEventToCurrentSequence(\n    sessionId: string | number,\n    event: string,\n  ): Promise<SendingSequencesReturn<KeyType> | undefined>;\n  abstract getSequencesToSend(): Promise<SendingSequencesReturn<KeyType>[] | undefined>;\n  abstract storeCurrentSequence(sessionId: number): Promise<SendingSequencesReturn<KeyType> | undefined>;\n  abstract storeSendingEvents(sessionId: string | number, events: Events): Promise<KeyType | undefined>;\n  abstract cleanUpSessionEventsStore(sessionId: number, sequenceId: KeyType): Promise<void>;\n\n  /**\n   * Calculates the character length of a string as size approximation\n   * Note: String length closely approximates byte size for most content\n   */\n  private getStringSize(str: string): number {\n    return str.length;\n  }\n\n  /**\n   * Calculates the total character length of events array\n   * Accounts for JSON serialization overhead when sent to backend\n   */\n  private getEventsArraySize(events: Events): number {\n    let totalSize = 0;\n    for (const event of events) {\n      totalSize += this.getStringSize(event);\n    }\n\n    // Additional overhead from using length instead of byte size\n    // - Array brackets: [] = 2 characters\n    // - Commas between events: events.length - 1\n    // - Double quotes around each event: events.length * 2\n    const overhead = 2 + Math.max(0, events.length - 1) + events.length * 2;\n\n    return totalSize + overhead;\n  }\n\n  /**\n   * Determines whether to send the events list to the backend and start a new\n   * empty events list, based on the size of the list as well as the last time sent\n   * @param nextEventString\n   * @returns boolean\n   */\n  shouldSplitEventsList = (events: Events, nextEventString: string): boolean => {\n    const sizeOfNextEvent = this.getStringSize(nextEventString);\n    const sizeOfEventsList = this.getEventsArraySize(events);\n\n    // Check size constraint first (most likely to trigger)\n    if (sizeOfEventsList + sizeOfNextEvent >= this.maxPersistedEventsSize) {\n      return true;\n    }\n    if (Date.now() - this.timeAtLastSplit > this.interval && events.length) {\n      this.interval = Math.min(this.maxInterval, this.interval + this.minInterval);\n      this._timeAtLastSplit = Date.now();\n      return true;\n    }\n    return false;\n  };\n}\n"]}