import { ILogger } from '@amplitude/analytics-core';
import { TargetingParameters } from '@amplitude/targeting';
import { LoggingConfig, SessionReplayJoinedConfig, SessionReplayJoinedConfigGenerator } from './config/types';
import { CustomRRwebEvent } from './constants';
import { EventCompressor } from './events/event-compressor';
import { AmplitudeSessionReplay, SessionReplayEventsManager as AmplitudeSessionReplayEventsManager, SessionIdentifiers as ISessionIdentifiers, SessionReplayOptions } from './typings/session-replay';
import type { RecordFunction } from './utils/rrweb';
type PageLeaveFn = (e: PageTransitionEvent | Event) => void;
export declare class SessionReplay implements AmplitudeSessionReplay {
    name: string;
    config: SessionReplayJoinedConfig | undefined;
    joinedConfigGenerator: SessionReplayJoinedConfigGenerator | undefined;
    identifiers: ISessionIdentifiers | undefined;
    eventsManager?: AmplitudeSessionReplayEventsManager<'replay' | 'interaction', string>;
    loggerProvider: ILogger;
    recordCancelCallback: ReturnType<RecordFunction> | null;
    eventCount: number;
    eventCompressor: EventCompressor | undefined;
    sessionTargetingMatch: boolean;
    private lastTargetingParams?;
    private lastShouldRecordDecision?;
    pageLeaveFns: PageLeaveFn[];
    private scrollHook?;
    private networkObservers?;
    private metadata;
    private recordFunction;
    constructor();
    init(apiKey: string, options: SessionReplayOptions): import("@amplitude/analytics-core").AmplitudeReturn<void>;
    private teardownEventListeners;
    protected _init(apiKey: string, options: SessionReplayOptions): Promise<void>;
    setSessionId(sessionId: string | number, deviceId?: string): import("@amplitude/analytics-core").AmplitudeReturn<void>;
    asyncSetSessionId(sessionId: string | number, deviceId?: string, options?: {
        userProperties?: {
            [key: string]: any;
        };
    }): Promise<void>;
    getSessionReplayProperties(): {
        [key: string]: string | null;
    };
    blurListener: () => void;
    focusListener: () => void;
    /**
     * This is an instance member so that if init is called multiple times
     * it doesn't add another listener to the page leave event. This is to
     * prevent duplicate listener actions from firing.
     */
    private pageLeaveListener;
    evaluateTargetingAndCapture: (targetingParams: Pick<TargetingParameters, 'event' | 'userProperties'>, isInit?: boolean) => Promise<void>;
    sendEvents(sessionId?: string | number): void;
    initialize(shouldSendStoredEvents?: boolean): Promise<void>;
    shouldOptOut(): boolean | undefined;
    getShouldRecord(): boolean;
    getBlockSelectors(): string | string[] | undefined;
    getMaskTextSelectors(): string | undefined;
    getRecordingPlugins(loggingConfig: LoggingConfig | undefined): Promise<(import("@amplitude/rrweb-types").RecordPlugin<import("./plugins/url-tracking-plugin").URLTrackingPluginOptions> | import("@amplitude/rrweb-types").RecordPlugin<unknown>)[] | undefined>;
    private getRecordFunction;
    recordEvents(shouldLogMetadata?: boolean): Promise<void>;
    addCustomRRWebEvent: (eventName: CustomRRwebEvent, eventData?: {
        [key: string]: any;
    }, addStorageInfo?: boolean) => Promise<void>;
    stopRecordingEvents: () => void;
    getDeviceId(): string | undefined;
    getSessionId(): string | number | undefined;
    flush(useRetry?: boolean): Promise<void | undefined>;
    shutdown(): void;
    private mapSDKType;
    private setMetadata;
    private initializeNetworkObservers;
}
export {};
//# sourceMappingURL=session-replay.d.ts.map