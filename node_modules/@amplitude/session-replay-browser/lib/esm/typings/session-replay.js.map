{"version":3,"file":"session-replay.js","sourceRoot":"","sources":["../../../src/typings/session-replay.ts"],"names":[],"mappings":"","sourcesContent":["import { AmplitudeReturn, ServerZone } from '@amplitude/analytics-core';\nimport { SessionReplayJoinedConfig, SessionReplayLocalConfig, SessionReplayVersion } from '../config/types';\nimport { TargetingParameters } from '@amplitude/targeting';\n\nexport type StorageData = {\n  totalStorageSize: number;\n  percentOfQuota: number;\n  usageDetails: string;\n};\n\nexport interface DebugInfo extends Partial<StorageData> {\n  config: SessionReplayJoinedConfig;\n  version: string;\n}\n\nexport type Events = string[];\n\nexport type StoreType = 'memory' | 'idb';\n\nexport type EventType = 'replay' | 'interaction';\n\nexport type ConsoleLogLevel = 'info' | 'log' | 'warn' | 'error';\n\nexport interface SessionReplayDestinationSessionMetadata {\n  type: EventType;\n  sessionId: string | number;\n  deviceId: string | undefined;\n  version?: SessionReplayVersion;\n}\n\nexport type SessionReplayDestination = {\n  events: Events;\n  flushMaxRetries?: number;\n  apiKey?: string;\n  sampleRate: number;\n  serverZone?: keyof typeof ServerZone;\n  onComplete: () => Promise<void>;\n} & SessionReplayDestinationSessionMetadata;\n\nexport interface SessionReplayDestinationContext extends SessionReplayDestination {\n  attempts: number;\n  timeout: number;\n}\n\nexport interface SendingSequencesReturn<KeyType> {\n  sequenceId: KeyType;\n  sessionId: string | number;\n  events: Events;\n}\n\n/**\n * This interface is not guaranteed to be stable, yet.\n */\nexport interface EventsStore<KeyType> {\n  getSequencesToSend(): Promise<SendingSequencesReturn<KeyType>[] | undefined>;\n  /**\n   * Moves current sequence of events to long term storage and resets short term storage.\n   */\n  storeCurrentSequence(sessionId: string | number): Promise<SendingSequencesReturn<KeyType> | undefined>;\n  /**\n   * Adds events to the current IDB sequence. Returns events that should be\n   * sent to the track destination right away if should split events is true.\n   */\n  addEventToCurrentSequence(\n    sessionId: string | number,\n    event: string,\n  ): Promise<SendingSequencesReturn<KeyType> | undefined>;\n  /**\n   * Returns the sequence id associated with the events batch.\n   * @returns the new sequence id or undefined if it cannot be determined or on any error.\n   */\n  storeSendingEvents(sessionId: string | number, events: Events): Promise<KeyType | undefined>;\n  /**\n   * Permanently removes the events batch for the session/sequence pair.\n   */\n  cleanUpSessionEventsStore(sessionId: string | number, sequenceId?: KeyType): Promise<void>;\n}\nexport interface SessionIdentifiers {\n  /**\n   * Sets an identifier for the device running your application.\n   */\n  deviceId?: string;\n  /**\n   * Sets an identifier for the users current session. The value must be in milliseconds since epoch (Unix Timestamp).\n   */\n  sessionId?: string | number;\n  sessionReplayId?: string;\n}\n\nexport type SessionReplayOptions = Omit<Partial<SessionReplayLocalConfig & SessionIdentifiers>, 'apiKey'>;\n\nexport interface AmplitudeSessionReplay {\n  init: (apiKey: string, options: SessionReplayOptions) => AmplitudeReturn<void>;\n  setSessionId: (sessionId: string | number, deviceId?: string) => AmplitudeReturn<void>;\n  getSessionId: () => string | number | undefined;\n  getSessionReplayProperties: () => { [key: string]: boolean | string | null };\n  evaluateTargetingAndCapture: (\n    targetingParams: Pick<TargetingParameters, 'event' | 'userProperties'>,\n    isInit?: boolean,\n  ) => Promise<void>;\n  flush: (useRetry: boolean) => Promise<void>;\n  shutdown: () => void;\n}\n\nexport interface SessionReplayTrackDestination {\n  /**\n   * Enqueues events to be sent.\n   */\n  sendEventsList: (destinationData: SessionReplayDestination) => void;\n  /**\n   * Immediately sends queued events.\n   */\n  flush: (useRetry: boolean) => Promise<void>;\n}\n\nexport type EventsManagerWithType<EventType, EventDataType> = {\n  name: EventType;\n  manager: SessionReplayEventsManager<EventType, EventDataType>;\n};\n\nexport interface SessionReplayEventsManager<Type, Event> {\n  /**\n   * For each sequence stored in the long term indexed DB send immediately to the track destination.\n   */\n  sendStoredEvents({ deviceId }: { deviceId: string }): Promise<void>;\n  /**\n   * Adds an event to the short term storage. If should split based on size or last sent, then send immediately.\n   */\n  addEvent({\n    sessionId,\n    event,\n    deviceId,\n  }: {\n    sessionId: string | number;\n    event: { type: Type; data: Event };\n    deviceId: string;\n  }): void;\n  /**\n   * Move events in short term storage to long term storage and send immediately to the track destination.\n   */\n  sendCurrentSequenceEvents({ sessionId, deviceId }: { sessionId: string | number; deviceId: string }): void;\n  /**\n   * Flush the track destination queue immediately. This should invoke sends for all the events in the queue.\n   */\n  flush(useRetry?: boolean): Promise<void>;\n}\n"]}