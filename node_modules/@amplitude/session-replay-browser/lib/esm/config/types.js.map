{"version":3,"file":"types.js","sourceRoot":"","sources":["../../../src/config/types.ts"],"names":[],"mappings":"AAkDA,MAAM,CAAC,IAAM,kBAAkB,GAAG,QAAQ,CAAC","sourcesContent":["import { IConfig, LogLevel, ILogger } from '@amplitude/analytics-core';\nimport { StoreType, ConsoleLogLevel } from '../typings/session-replay';\nimport { TargetingFlag } from '@amplitude/targeting';\n\nexport interface SamplingConfig {\n  sample_rate: number;\n  capture_enabled: boolean;\n}\n\nexport interface InteractionConfig {\n  trackEveryNms?: number;\n  enabled: boolean; // defaults to false\n  batch: boolean; // defaults to false\n  /**\n   * UGC filter rules.\n   */\n  ugcFilterRules?: UGCFilterRule[];\n}\n\nexport interface LoggingConfig {\n  console: {\n    enabled: boolean;\n    levels: ConsoleLogLevel[];\n  };\n  network?: {\n    enabled: boolean;\n  };\n}\n\nexport type TargetingConfig = TargetingFlag;\n\nexport type SessionReplayRemoteConfig = {\n  sr_sampling_config?: SamplingConfig;\n  sr_privacy_config?: PrivacyConfig;\n  sr_interaction_config?: InteractionConfig;\n  sr_logging_config?: LoggingConfig;\n  sr_targeting_config?: TargetingConfig;\n};\n\nexport interface SessionReplayRemoteConfigAPIResponse {\n  configs: {\n    sessionReplay: SessionReplayRemoteConfig;\n  };\n}\n\nexport type MaskLevel =\n  | 'light' // only mask a subset of inputs that's deemed sensitive - password, credit card, telephone #, email. These are information we never want to capture.\n  | 'medium' // mask all inputs\n  | 'conservative'; // mask all inputs and all texts\n\nexport const DEFAULT_MASK_LEVEL = 'medium';\n\n// err on the side of excluding more\nexport type PrivacyConfig = {\n  blockSelector?: string | string[]; // exclude in the UI\n  defaultMaskLevel?: MaskLevel;\n  maskSelector?: string[];\n  unmaskSelector?: string[];\n};\n\n/**\n * UGC filter rule.\n */\nexport type UGCFilterRule = {\n  /**\n   * The selector of the UGC element.\n   */\n  selector: string;\n  /**\n   * The replacement text for the UGC element.\n   */\n  replacement: string;\n};\n\nexport interface SessionReplayLocalConfig extends IConfig {\n  apiKey: string;\n  loggerProvider: ILogger;\n  /**\n   * LogLevel.None or LogLevel.Error or LogLevel.Warn or LogLevel.Verbose or LogLevel.Debug.\n   * Sets the log level.\n   *\n   * @defaultValue LogLevel.Warn\n   */\n  logLevel: LogLevel;\n  /**\n   * The maximum number of retries allowed for sending replay events.\n   * Once this limit is reached, failed events will no longer be sent.\n   *\n   * @defaultValue 2\n   */\n  flushMaxRetries: number;\n  /**\n   * Use this option to control how many sessions to select for replay collection.\n   * The number should be a decimal between 0 and 1, for example 0.4, representing\n   * the fraction of sessions to have randomly selected for replay collection.\n   * Over a large number of sessions, 0.4 would select 40% of those sessions.\n   * Sample rates as small as six decimal places (0.000001) are supported.\n   *\n   * @defaultValue 0\n   */\n  sampleRate: number;\n  privacyConfig?: PrivacyConfig;\n  /**\n   * Adds additional debug event property to help debug instrumentation issues\n   * (such as mismatching apps). Only recommended for debugging initial setup,\n   * and not recommended for production.\n   */\n  debugMode?: boolean;\n  /**\n   * Specifies the endpoint URL to fetch remote configuration.\n   * If provided, it overrides the default server zone configuration.\n   */\n  configServerUrl?: string;\n  /**\n   * Specifies the endpoint URL for sending session replay data.\n   * If provided, it overrides the default server zone configuration.\n   */\n  trackServerUrl?: string;\n  /**\n   * If stylesheets are inlined, the contents of the stylesheet will be stored.\n   * During replay, the stored stylesheet will be used instead of attempting to fetch it remotely.\n   * This prevents replays from appearing broken due to missing stylesheets.\n   * Note: Inlining stylesheets may not work in all cases.\n   */\n  shouldInlineStylesheet?: boolean;\n  version?: SessionReplayVersion;\n  /**\n   * Performance configuration config. If enabled, we will defer compression\n   * to be done during the browser's idle periods.\n   */\n  performanceConfig?: SessionReplayPerformanceConfig;\n  /**\n   * Specifies how replay events should be stored. `idb` uses IndexedDB to persist replay events\n   * when all events cannot be sent during capture. `memory` stores replay events only in memory,\n   * meaning events are lost when the page is closed. If IndexedDB is unavailable, the system falls back to `memory`.\n   */\n  storeType: StoreType;\n\n  /**\n   * Experimental features.\n   */\n  experimental?: {\n    /**\n     * If the SDK should compress the replay events using a webworker.\n     */\n    useWebWorker: boolean;\n  };\n  userProperties?: { [key: string]: any };\n\n  /**\n   * Remove certain parts of the DOM from being captured. These are typically ignored when blocking by selectors.\n   */\n  omitElementTags?: {\n    /**\n     * If true, removes script tags from the DOM, but not noscript tags.\n     */\n    script?: boolean;\n    /**\n     * If true, removes comment tags from the DOM.\n     */\n    comment?: boolean;\n  };\n\n  /**\n   * If true, applies a background color to blocked elements in the replay.\n   * This helps visualize which elements are blocked from being captured.\n   */\n  applyBackgroundColorToBlockedElements?: boolean;\n  /**\n   * Enables URL change polling as a fallback for SPA route tracking.\n   * When enabled, the SDK will periodically check for URL changes every second\n   * in addition to patching the History API. This is useful for edge cases where\n   * route changes might bypass the standard History API methods.\n   *\n   * @defaultValue false\n   */\n  enableUrlChangePolling?: boolean;\n  /**\n   * Specifies the interval in milliseconds for URL change polling when enableUrlChangePolling is true.\n   * The SDK will check for URL changes at this interval as a fallback for SPA route tracking.\n   *\n   * @defaultValue 1000\n   */\n  urlChangePollingInterval?: number;\n  /**\n   * Whether to capture document title in URL change events.\n   * When disabled, the title field will be empty in URL change events.\n   *\n   * @defaultValue false\n   */\n  captureDocumentTitle?: boolean;\n  interactionConfig?: InteractionConfig;\n}\n\nexport interface SessionReplayJoinedConfig extends SessionReplayLocalConfig {\n  captureEnabled?: boolean;\n  interactionConfig?: InteractionConfig;\n  loggingConfig?: LoggingConfig;\n  targetingConfig?: TargetingConfig;\n}\n\nexport interface SessionReplayRemoteConfigFetch {\n  getServerUrl: () => void;\n  getSamplingConfig: (sessionId?: number) => Promise<SessionReplayRemoteConfig['sr_sampling_config'] | void>;\n  fetchRemoteConfig: (sessionId?: number) => Promise<SessionReplayRemoteConfig | void>;\n  getRemoteConfig: (sessionId?: number) => Promise<SessionReplayRemoteConfig | void>;\n}\n\nexport interface SessionReplayConfigs {\n  localConfig: SessionReplayLocalConfig;\n  joinedConfig: SessionReplayJoinedConfig;\n  remoteConfig: SessionReplayRemoteConfig | undefined;\n}\nexport interface SessionReplayJoinedConfigGenerator {\n  generateJoinedConfig: (sessionId?: string | number) => Promise<SessionReplayConfigs>;\n}\n\nexport interface SessionReplayMetadata {\n  remoteConfig: SessionReplayRemoteConfig | undefined;\n  localConfig: SessionReplayLocalConfig;\n  joinedConfig: SessionReplayJoinedConfig;\n  framework?: {\n    name: string;\n    version: string;\n  };\n  sessionId: string | number | undefined;\n  hashValue?: number;\n  sampleRate: number;\n  replaySDKType: string | null;\n  replaySDKVersion: string | undefined;\n  standaloneSDKType: string;\n  standaloneSDKVersion: string | undefined;\n}\n\nexport interface SessionReplayVersion {\n  version: string;\n  type: SessionReplayType;\n}\n\n/**\n * Configuration options for session replay performance.\n */\nexport interface SessionReplayPerformanceConfig {\n  /**\n   * If enabled, event compression will be deferred to occur during the browser's idle periods.\n   */\n  enabled: boolean;\n  /**\n   * Optional timeout in milliseconds for the `requestIdleCallback` API.\n   * If specified, this value will be used to set a maximum time for the browser to wait\n   * before executing the deferred compression task, even if the browser is not idle.\n   */\n  timeout?: number;\n}\n\nexport type SessionReplayType = 'standalone' | 'plugin' | 'segment';\n"]}