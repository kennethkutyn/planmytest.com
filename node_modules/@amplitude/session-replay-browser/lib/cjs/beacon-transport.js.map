{"version":3,"file":"beacon-transport.js","sourceRoot":"","sources":["../../src/beacon-transport.ts"],"names":[],"mappings":";;;AAAA,4DAA2D;AAG3D,qCAAyC;AAIzC;;;;;;;;;;;;;;;GAeG;AACH;IAOE,yBAAY,OAAkE,EAAE,MAAiC;QAC/G,IAAM,WAAW,GAAG,IAAA,+BAAc,GAAE,CAAC;QACrC,IAAI,WAAW,IAAI,WAAW,CAAC,SAAS,IAAI,OAAO,WAAW,CAAC,SAAS,CAAC,UAAU,KAAK,UAAU,EAAE;YAClG,IAAI,CAAC,UAAU,GAAG,UAAC,OAAO,EAAE,OAAO;gBACjC,IAAI;oBACF,IAAI,WAAW,CAAC,SAAS,CAAC,UAAU,CAAC,OAAO,EAAE,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,EAAE;wBACtE,OAAO,IAAI,CAAC;qBACb;iBACF;gBAAC,OAAO,CAAC,EAAE;oBACV,4EAA4E;iBAC7E;gBACD,OAAO,KAAK,CAAC;YACf,CAAC,CAAC;SACH;aAAM;YACL,IAAI,CAAC,UAAU,GAAG,cAAM,OAAA,KAAK,EAAL,CAAK,CAAC;SAC/B;QAED,IAAI,CAAC,OAAO,GAAG,UAAC,OAAO,EAAE,OAAO;YAC9B,IAAM,GAAG,GAAG,IAAI,cAAc,EAAE,CAAC;YACjC,GAAG,CAAC,IAAI,CAAC,MAAM,EAAE,OAAO,EAAE,IAAI,CAAC,CAAC;YAChC,GAAG,CAAC,gBAAgB,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;YACtC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC;YAClC,OAAO,IAAI,CAAC;QACd,CAAC,CAAC;QAEF,IAAI,CAAC,WAAW,GAAG,IAAA,sBAAY,EAAC,MAAM,CAAC,UAAU,EAAE,MAAM,CAAC,cAAc,CAAC,CAAC;QAC1E,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC;QAC5B,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;IACzB,CAAC;IAED,8BAAI,GAAJ,UAAK,QAAgB,EAAE,OAAU;QACzB,IAAA,KAAsB,IAAI,CAAC,OAAO,EAAhC,SAAS,eAAA,EAAE,IAAI,UAAiB,CAAC;QACzC,IAAM,SAAS,GAAG,IAAI,eAAe,CAAC;YACpC,SAAS,EAAE,QAAQ;YACnB,UAAU,EAAE,MAAM,CAAC,SAAS,CAAC;YAC7B,IAAI,EAAE,MAAM,CAAC,IAAI,CAAC;YAClB,OAAO,EAAE,IAAI,CAAC,MAAM;SACrB,CAAC,CAAC;QAEH,IAAM,OAAO,GAAG,UAAG,IAAI,CAAC,WAAW,cAAI,SAAS,CAAC,QAAQ,EAAE,CAAE,CAAC;QAE9D,kGAAkG;QAClG,+DAA+D;QAC/D,IAAI,CAAC,UAAU,CAAC,OAAO,EAAE,OAAO,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;IACtE,CAAC;IACH,sBAAC;AAAD,CAAC,AApDD,IAoDC;AApDY,0CAAe","sourcesContent":["import { getGlobalScope } from '@amplitude/analytics-core';\nimport { SessionReplayJoinedConfig } from './config/types';\nimport { SessionReplayDestinationSessionMetadata } from './typings/session-replay';\nimport { getServerUrl } from './helpers';\n\ntype BeaconSendFn<T> = (pageUrl: string, payload: T) => boolean;\n\n/**\n * For very small payloads it's preferable to use the [Beacon API](https://developer.mozilla.org/en-US/docs/Web/API/Beacon_API).\n * While it doesn't provide 100% guarantees on sends, it greatly helps with overall reliability and page load performance. As\n * the Beacon API has a potential to fail due to size constraints we want to fall back to XHR if need be. This is mostly to\n * be used with 'pagehide' or 'beforeunload' events.\n *\n * Note there are only 3 CORS safelisted Content-Types you can send:\n *\n * - application/x-www-form-urlencoded\n * - multipart/form-data\n * - text/plain\n *\n * If we do not send one of these, some browsers like Chrome may not send this at all. Also we incur the overhead of a preflight\n * request. In our case we will add no additional content-type header. If you are trying to ping a server that requires this\n * header, you may want to use the regular fetch API or a different mechanism.\n */\nexport class BeaconTransport<T> {\n  private sendBeacon: BeaconSendFn<T>;\n  private sendXhr: BeaconSendFn<T>;\n  private readonly basePageUrl: string;\n  private readonly context: Omit<SessionReplayDestinationSessionMetadata, 'deviceId'>;\n  private readonly apiKey: string;\n\n  constructor(context: Omit<SessionReplayDestinationSessionMetadata, 'deviceId'>, config: SessionReplayJoinedConfig) {\n    const globalScope = getGlobalScope();\n    if (globalScope && globalScope.navigator && typeof globalScope.navigator.sendBeacon === 'function') {\n      this.sendBeacon = (pageUrl, payload) => {\n        try {\n          if (globalScope.navigator.sendBeacon(pageUrl, JSON.stringify(payload))) {\n            return true;\n          }\n        } catch (e) {\n          // not logging error, since it would be hard to view and just adds overhead.\n        }\n        return false;\n      };\n    } else {\n      this.sendBeacon = () => false;\n    }\n\n    this.sendXhr = (pageUrl, payload) => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('POST', pageUrl, true);\n      xhr.setRequestHeader('Accept', '*/*');\n      xhr.send(JSON.stringify(payload));\n      return true;\n    };\n\n    this.basePageUrl = getServerUrl(config.serverZone, config.trackServerUrl);\n    this.apiKey = config.apiKey;\n    this.context = context;\n  }\n\n  send(deviceId: string, payload: T) {\n    const { sessionId, type } = this.context;\n    const urlParams = new URLSearchParams({\n      device_id: deviceId,\n      session_id: String(sessionId),\n      type: String(type),\n      api_key: this.apiKey,\n    });\n\n    const pageUrl = `${this.basePageUrl}?${urlParams.toString()}`;\n\n    // ideally send using the beacon API, but there is a chance it may fail, possibly due to a payload\n    // size limit. in this case, try best effort to send using xhr.\n    this.sendBeacon(pageUrl, payload) || this.sendXhr(pageUrl, payload);\n  }\n}\n"]}