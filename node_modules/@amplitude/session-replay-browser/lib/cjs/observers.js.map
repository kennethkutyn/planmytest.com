{"version":3,"file":"observers.js","sourceRoot":"","sources":["../../src/observers.ts"],"names":[],"mappings":";;;;AAAA,4DAA2D;AAmB3D;IAAA;QACU,kBAAa,GAAwB,IAAI,CAAC;IAuEpD,CAAC;IApEC,gCAAK,GAAL,UAAM,aAAmC;QACvC,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC;QACnC,IAAI,CAAC,YAAY,EAAE,CAAC;IACtB,CAAC;IAED,+BAAI,GAAJ;;QACE,MAAA,IAAI,CAAC,aAAa,oDAAI,CAAC;QACvB,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;QAC1B,IAAI,CAAC,aAAa,GAAG,SAAS,CAAC;IACjC,CAAC;IAES,sCAAW,GAArB,UAAsB,KAA0B;;QAC9C,MAAA,IAAI,CAAC,aAAa,qDAAG,KAAK,CAAC,CAAC;IAC9B,CAAC;IAEO,uCAAY,GAApB;QAAA,iBAoDC;QAnDC,IAAM,WAAW,GAAG,IAAA,+BAAc,GAAE,CAAC;QACrC,IAAI,CAAC,WAAW;YAAE,OAAO;QAEzB,IAAM,aAAa,GAAG,WAAW,CAAC,KAAK,CAAC;QACxC,IAAI,CAAC,aAAa;YAAE,OAAO;QAE3B,WAAW,CAAC,KAAK,GAAG,UAAO,KAAwB,EAAE,IAAkB;;;;;wBAC/D,SAAS,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;wBACvB,YAAY,GAAwB;4BACxC,SAAS,EAAE,SAAS;4BACpB,IAAI,EAAE,OAAO;4BACb,MAAM,EAAE,CAAA,IAAI,aAAJ,IAAI,uBAAJ,IAAI,CAAE,MAAM,KAAI,KAAK;4BAC7B,GAAG,EAAE,KAAK,CAAC,QAAQ,EAAE;4BACrB,cAAc,EAAE,IAAI,aAAJ,IAAI,uBAAJ,IAAI,CAAE,OAAiC;yBACxD,CAAC;;;;wBAGiB,qBAAM,aAAa,CAAC,KAAK,EAAE,IAAI,CAAC,EAAA;;wBAA3C,QAAQ,GAAG,SAAgC;wBAC3C,OAAO,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;wBAE3B,YAAY,CAAC,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC;wBACtC,YAAY,CAAC,QAAQ,GAAG,OAAO,GAAG,SAAS,CAAC;wBAGtC,YAAkC,EAAE,CAAC;wBAC3C,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,UAAC,KAAK,EAAE,GAAG;4BAClC,SAAO,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;wBACvB,CAAC,CAAC,CAAC;wBACH,YAAY,CAAC,eAAe,GAAG,SAAO,CAAC;wBAEvC,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC,CAAC;wBAC/B,sBAAO,QAAQ,EAAC;;;wBAEV,OAAO,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;wBAC3B,YAAY,CAAC,QAAQ,GAAG,OAAO,GAAG,SAAS,CAAC;wBAGtC,UAAU,GAAG,OAAc,CAAC;wBAClC,YAAY,CAAC,KAAK,GAAG;4BACnB,IAAI,EAAE,UAAU,CAAC,IAAI,IAAI,cAAc;4BACvC,OAAO,EAAE,UAAU,CAAC,OAAO,IAAI,2BAA2B;yBAC3D,CAAC;wBAEF,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC,CAAC;wBAC/B,MAAM,OAAK,CAAC;;;;aAEf,CAAC;QAEF,IAAI,CAAC,aAAa,GAAG;YACnB,WAAW,CAAC,KAAK,GAAG,aAAa,CAAC;QACpC,CAAC,CAAC;IACJ,CAAC;IACH,uBAAC;AAAD,CAAC,AAxED,IAwEC;AAxEY,4CAAgB","sourcesContent":["import { getGlobalScope } from '@amplitude/analytics-core';\n\nexport interface NetworkRequestEvent {\n  timestamp: number;\n  type: 'fetch';\n  method: string;\n  url: string;\n  status?: number;\n  duration?: number;\n  requestHeaders?: Record<string, string>;\n  responseHeaders?: Record<string, string>;\n  error?: {\n    name: string;\n    message: string;\n  };\n}\n\nexport type NetworkEventCallback = (event: NetworkRequestEvent) => void;\n\nexport class NetworkObservers {\n  private fetchObserver: (() => void) | null = null;\n  private eventCallback?: NetworkEventCallback;\n\n  start(eventCallback: NetworkEventCallback) {\n    this.eventCallback = eventCallback;\n    this.observeFetch();\n  }\n\n  stop() {\n    this.fetchObserver?.();\n    this.fetchObserver = null;\n    this.eventCallback = undefined;\n  }\n\n  protected notifyEvent(event: NetworkRequestEvent) {\n    this.eventCallback?.(event);\n  }\n\n  private observeFetch() {\n    const globalScope = getGlobalScope();\n    if (!globalScope) return;\n\n    const originalFetch = globalScope.fetch;\n    if (!originalFetch) return;\n\n    globalScope.fetch = async (input: RequestInfo | URL, init?: RequestInit) => {\n      const startTime = Date.now();\n      const requestEvent: NetworkRequestEvent = {\n        timestamp: startTime,\n        type: 'fetch',\n        method: init?.method || 'GET', // Fetch API defaulted to GET when no method is provided\n        url: input.toString(),\n        requestHeaders: init?.headers as Record<string, string>,\n      };\n\n      try {\n        const response = await originalFetch(input, init);\n        const endTime = Date.now();\n\n        requestEvent.status = response.status;\n        requestEvent.duration = endTime - startTime;\n\n        // Convert Headers\n        const headers: Record<string, string> = {};\n        response.headers.forEach((value, key) => {\n          headers[key] = value;\n        });\n        requestEvent.responseHeaders = headers;\n\n        this.notifyEvent(requestEvent);\n        return response;\n      } catch (error) {\n        const endTime = Date.now();\n        requestEvent.duration = endTime - startTime;\n\n        // Capture error information\n        const typedError = error as Error;\n        requestEvent.error = {\n          name: typedError.name || 'UnknownError',\n          message: typedError.message || 'An unknown error occurred',\n        };\n\n        this.notifyEvent(requestEvent);\n        throw error;\n      }\n    };\n\n    this.fetchObserver = () => {\n      globalScope.fetch = originalFetch;\n    };\n  }\n}\n"]}