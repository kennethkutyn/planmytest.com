"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.targetingIDBStore = exports.TargetingIDBStore = exports.MAX_IDB_STORAGE_LENGTH = void 0;
var tslib_1 = require("tslib");
var idb_1 = require("idb");
exports.MAX_IDB_STORAGE_LENGTH = 1000 * 60 * 60 * 24 * 2; // 2 days
var TargetingIDBStore = /** @class */ (function () {
    function TargetingIDBStore() {
        var _this = this;
        this.dbs = {};
        this.createStore = function (dbName) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, idb_1.openDB)(dbName, 1, {
                            upgrade: function (db) {
                                if (!db.objectStoreNames.contains('sessionTargetingMatch')) {
                                    db.createObjectStore('sessionTargetingMatch', {
                                        keyPath: 'sessionId',
                                    });
                                }
                            },
                        })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        }); };
        this.openOrCreateDB = function (apiKey) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var dbName, db;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.dbs && this.dbs[apiKey]) {
                            return [2 /*return*/, this.dbs[apiKey]];
                        }
                        dbName = "".concat(apiKey.substring(0, 10), "_amp_session_replay_targeting");
                        return [4 /*yield*/, this.createStore(dbName)];
                    case 1:
                        db = _a.sent();
                        this.dbs[apiKey] = db;
                        return [2 /*return*/, db];
                }
            });
        }); };
        this.getTargetingMatchForSession = function (_a) {
            var loggerProvider = _a.loggerProvider, apiKey = _a.apiKey, sessionId = _a.sessionId;
            return tslib_1.__awaiter(_this, void 0, void 0, function () {
                var db, sessionIdStr, targetingMatchForSession, e_1;
                return tslib_1.__generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            _b.trys.push([0, 3, , 4]);
                            return [4 /*yield*/, this.openOrCreateDB(apiKey)];
                        case 1:
                            db = _b.sent();
                            sessionIdStr = String(sessionId);
                            return [4 /*yield*/, db.get('sessionTargetingMatch', sessionIdStr)];
                        case 2:
                            targetingMatchForSession = _b.sent();
                            return [2 /*return*/, targetingMatchForSession === null || targetingMatchForSession === void 0 ? void 0 : targetingMatchForSession.targetingMatch];
                        case 3:
                            e_1 = _b.sent();
                            loggerProvider.warn("Failed to get targeting match for session id ".concat(sessionId, ": ").concat(e_1));
                            return [3 /*break*/, 4];
                        case 4: return [2 /*return*/, undefined];
                    }
                });
            });
        };
        this.storeTargetingMatchForSession = function (_a) {
            var loggerProvider = _a.loggerProvider, apiKey = _a.apiKey, sessionId = _a.sessionId, targetingMatch = _a.targetingMatch;
            return tslib_1.__awaiter(_this, void 0, void 0, function () {
                var db, sessionIdStr, targetingMatchForSession, e_2;
                return tslib_1.__generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            _b.trys.push([0, 3, , 4]);
                            return [4 /*yield*/, this.openOrCreateDB(apiKey)];
                        case 1:
                            db = _b.sent();
                            sessionIdStr = String(sessionId);
                            return [4 /*yield*/, db.put('sessionTargetingMatch', {
                                    targetingMatch: targetingMatch,
                                    sessionId: sessionIdStr,
                                    lastUpdated: Date.now(),
                                })];
                        case 2:
                            targetingMatchForSession = _b.sent();
                            return [2 /*return*/, targetingMatchForSession];
                        case 3:
                            e_2 = _b.sent();
                            loggerProvider.warn("Failed to store targeting match for session id ".concat(sessionId, ": ").concat(e_2));
                            return [3 /*break*/, 4];
                        case 4: return [2 /*return*/, undefined];
                    }
                });
            });
        };
        this.clearStoreOfOldSessions = function (_a) {
            var loggerProvider = _a.loggerProvider, apiKey = _a.apiKey, currentSessionId = _a.currentSessionId;
            return tslib_1.__awaiter(_this, void 0, void 0, function () {
                var db, currentSessionIdStr, tx, allTargetingMatchObjs, i, targetingMatchObj, amountOfTimeSinceSession, e_3;
                return tslib_1.__generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            _b.trys.push([0, 8, , 9]);
                            return [4 /*yield*/, this.openOrCreateDB(apiKey)];
                        case 1:
                            db = _b.sent();
                            currentSessionIdStr = String(currentSessionId);
                            tx = db.transaction('sessionTargetingMatch', 'readwrite');
                            return [4 /*yield*/, tx.store.getAll()];
                        case 2:
                            allTargetingMatchObjs = _b.sent();
                            i = 0;
                            _b.label = 3;
                        case 3:
                            if (!(i < allTargetingMatchObjs.length)) return [3 /*break*/, 6];
                            targetingMatchObj = allTargetingMatchObjs[i];
                            amountOfTimeSinceSession = Date.now() - targetingMatchObj.lastUpdated;
                            if (!(targetingMatchObj.sessionId !== currentSessionIdStr && amountOfTimeSinceSession > exports.MAX_IDB_STORAGE_LENGTH)) return [3 /*break*/, 5];
                            return [4 /*yield*/, tx.store.delete(targetingMatchObj.sessionId)];
                        case 4:
                            _b.sent();
                            _b.label = 5;
                        case 5:
                            i++;
                            return [3 /*break*/, 3];
                        case 6: return [4 /*yield*/, tx.done];
                        case 7:
                            _b.sent();
                            return [3 /*break*/, 9];
                        case 8:
                            e_3 = _b.sent();
                            loggerProvider.warn("Failed to clear old targeting matches for sessions: ".concat(e_3));
                            return [3 /*break*/, 9];
                        case 9: return [2 /*return*/];
                    }
                });
            });
        };
    }
    return TargetingIDBStore;
}());
exports.TargetingIDBStore = TargetingIDBStore;
exports.targetingIDBStore = new TargetingIDBStore();
//# sourceMappingURL=targeting-idb-store.js.map