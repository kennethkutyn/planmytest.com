"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetworkObservers = void 0;
var tslib_1 = require("tslib");
var analytics_core_1 = require("@amplitude/analytics-core");
var NetworkObservers = /** @class */ (function () {
    function NetworkObservers() {
        this.fetchObserver = null;
    }
    NetworkObservers.prototype.start = function (eventCallback) {
        this.eventCallback = eventCallback;
        this.observeFetch();
    };
    NetworkObservers.prototype.stop = function () {
        var _a;
        (_a = this.fetchObserver) === null || _a === void 0 ? void 0 : _a.call(this);
        this.fetchObserver = null;
        this.eventCallback = undefined;
    };
    NetworkObservers.prototype.notifyEvent = function (event) {
        var _a;
        (_a = this.eventCallback) === null || _a === void 0 ? void 0 : _a.call(this, event);
    };
    NetworkObservers.prototype.observeFetch = function () {
        var _this = this;
        var globalScope = (0, analytics_core_1.getGlobalScope)();
        if (!globalScope)
            return;
        var originalFetch = globalScope.fetch;
        if (!originalFetch)
            return;
        globalScope.fetch = function (input, init) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var startTime, requestEvent, response, endTime, headers_1, error_1, endTime, typedError;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        startTime = Date.now();
                        requestEvent = {
                            timestamp: startTime,
                            type: 'fetch',
                            method: (init === null || init === void 0 ? void 0 : init.method) || 'GET',
                            url: input.toString(),
                            requestHeaders: init === null || init === void 0 ? void 0 : init.headers,
                        };
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, originalFetch(input, init)];
                    case 2:
                        response = _a.sent();
                        endTime = Date.now();
                        requestEvent.status = response.status;
                        requestEvent.duration = endTime - startTime;
                        headers_1 = {};
                        response.headers.forEach(function (value, key) {
                            headers_1[key] = value;
                        });
                        requestEvent.responseHeaders = headers_1;
                        this.notifyEvent(requestEvent);
                        return [2 /*return*/, response];
                    case 3:
                        error_1 = _a.sent();
                        endTime = Date.now();
                        requestEvent.duration = endTime - startTime;
                        typedError = error_1;
                        requestEvent.error = {
                            name: typedError.name || 'UnknownError',
                            message: typedError.message || 'An unknown error occurred',
                        };
                        this.notifyEvent(requestEvent);
                        throw error_1;
                    case 4: return [2 /*return*/];
                }
            });
        }); };
        this.fetchObserver = function () {
            globalScope.fetch = originalFetch;
        };
    };
    return NetworkObservers;
}());
exports.NetworkObservers = NetworkObservers;
//# sourceMappingURL=observers.js.map